{"pages":[],"posts":[{"title":"TEST","text":"제목안녕하세요","link":"/2021/01/05/TEST/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/01/04/hello-world/"},{"title":"연습","text":"markdown 오늘 배운 내용 hexo markdown 오늘 만난 사람 오늘 생각한 아이디어 오늘은 markdown을 살짝 배웠어요!! 구글링 해서 찾아봐야지!!구글링하러 gogo!! 12345678910111213141516171819202122232425262728# markdown### 개요 ------TIL ( Today I Learned ) 블로그를 하는 목적- markdown ([총정리블로그](https://heropy.blog/2017/09/30/markdown/) ) &amp; vim 숙련- 잔디밭&lt;br&gt;#### 최근 들은 세션------1. 처음 시작하는 Git/Github 활용하기 ( OOS 개발자 포럼, 박희찬슈퍼 개발자님 ) [강의자료](https://bit.ly/git-starter)&lt;br&gt;#### 학습할자료------[슈퍼어메이징한터미널세팅](https://johngrib.github.io/wiki/my-mac-os-terminal/?fbclid=IwAR2QRRoeZv6L2sMbwmecLI5xJRObKmFHwxPmQ8OqR06w31Q8LcIpRijIfVs)[초보몽키개발공부로그](https://wayhome25.github.io/)[hexo적용한블로그태마깃헙](https://github.com/ppoffice/hexo-theme-icarus)[hexo적용한블로그사용법페이지](https://blog.zhangruipeng.me/hexo-theme-icarus/)[재원님disqus댓글기능추가하는방법](https://cresumerjang.github.io/2019/11/17/hexo-add-comments/?fbclid=IwAR0bHcNEprnoP1-28DVBkGq32MXaN_e4jGmhsF03XCNZsOgyzxj_aTkaHrU)&lt;br&gt;","link":"/2021/01/05/%EC%97%B0%EC%8A%B5/"},{"title":"스프링부트_시작하기","text":"* 스프링 부트와 AWS로 혼자 구현하는 웹 서비스(프리렉, 이동욱 지음)책을 통해 공부한 내용을 정리한 글입니다. * 목록 그레이들 프로젝트 변경 코드 설명 그레이들 프로젝트 변경먼저 intellij에서 gradle기반의 자바 프로젝트를 생성합니다.프로젝트 생성후 build.gradle 파일을 열어 보면 다음과 같은 코드가 있습니다. build.gradle 초기 상태12345678910111213141516plugins: { 'java'}group 'com.doop.book'version '1.0-SNAPSHOT'sourceCompatibility = 1.8repositories { mavenCentral()}dependencies { testCompile group: 'junit', name: 'junit', version: '4.12'} 이 코드들은 자바 개발에 가장 기초적인 설정만 되어있는 상태입니다. 이 코드에 스프링 부트에 필요한 설정들을 추가해 봅시다. build.gradle 수정후123456789101112131415161718192021222324252627282930buildscript { ext { springBootVersion = '2.1.7.RELEASE' } repositories { mavenCentral() jcenter() } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot;) }}apply plugin: 'java'apply plugin: 'eclipse'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management'group 'com.doop.book'version '1.0-SNAPSHOT'sourceCompatibility = 1.8repositories { mavenCentral()}dependencies { compile('org.springframework.boot:spring-boot-starter-web') testCompile('org.springframework.boot:spring-boot-starter-test')} 코드 설명123456789101112buildscript { ext { springBootVersion = '2.1.7.RELEASE' } repositories { mavenCentral() jcenter() } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot;) }} 이 코드는 프로젝트의 플러그인 의존성 관리를 위한 설정입니다.(인텔리제이의 플러그인 관리는 아님니다.)ext 라는 키워드는 build.gradle에서 사용하는 전역변수를 전역변수로 사용하겠다는 의미인데, 이 코드에서는 springBootVersion 라는 전역변수를 선언 후 값을 2.1.7.RELEASE로 하겠다는 의미입니다.classpath줄은 ‘spring-boot-gradle-plugin’ 라는 스프링 부트 그레이들 플러그인의 2.1.7.RELEASE를 의존성으로 받겠다는 의미입니다. 1234apply plugin: 'java'apply plugin: 'eclipse'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management' 위의 플러그인 4개는 자바와 스프링 부트를 사용하기 위한 필수 플러그인입니다.io.spring.dependency.management 플러그인은 스프링 부트의 의존성을 관리해 주는 플러그인이라 꼭 추가해야 합니다. 123456789repositories { mavenCentral() jcenter()}dependencies { compile('org.springframework.boot:spring-boot-starter-web') testCompile('org.springframework.boot:spring-boot-starter-test')} repositories 각종 의존성(라이브러리)들을 어떤 원격 저장소에서 받을지를 정합니다. 기본적으로 mavenCentral을 많이 사용하지만, 최근에는 라이브러리 업로드 난이도 때문에 jcenter도 많이 사용합니다. dependencies 프로젝트 개발에 필요한 의존성들을 선언하는 곳입니다. 인텔리제이는 메이븐 저장소의 데이터를 인덱싱해서 관리하기 때문에 의존성 자동완성이 가능합니다. complie 메소드 안에 라이브러리의 이름의 앞부분만 추가한 뒤 자동완성(Ctrl+Space) 을 사용하면 라이브러리 목록을 확인 할 수 있습니다. 의존성 코드는 직접 작성해도 되고, 자동완성으로 작성해도 됩니다. 단, 특정 버전을 명시하면 안 됩니다. 왜냐하면 버전을 명시하지 않아야만 맨위에 작성한 org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion} 의 버전을 따라가게 됩니다. build.gradle에 반영하기코드 설정이 끝이나면 오른쪽 하단에 Event Log에서 build.gradle에 변경이 있으니 반영하라 라는 알람이 나옵니다.[Import Changes]는 1회 변경을 허용하는 것이고, [Enable Auto-Import]는 수정될때 마다 자동으로 반영이 되는 것입니다.(필자는 이것이 나오지 않아 수동으로 반영하였다.) build 적용이 안될 시오류가 뜬다면 gradle의 버전을 확인해 봅시다.터미널에 다음과 같은 명령어를 치면 그레이들의 버전을 확인할수 있습니다. 1gradlew --version 버전이 5.x.x라면 4.x.x 로 바꾸어 줍니다. 1gradlew wrapper --gradle-version 4.10.2","link":"/2021/01/06/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"테스트코드_작성하기","text":"* 스프링 부트와 AWS로 혼자 구현하는 웹 서비스(프리렉, 이동욱 지음)책을 통해 공부한 내용을 정리한 글입니다. * 목록 TDD와 단위 테스트 TDD 단위 테스트 테스트 코드를 작성하는 이유 테스트 코드 작성하기 main 클래스 작성하기 내장 WAS를 사용을 권장하는 이유 test 코드 작성하기 자바 롬복(Lombok) 설치 Hello Controller 코드 롬복으로 전환하기 assertj의 장점 TDD와 단위 테스트TDD테스트가 주도하는 개발을 이야기합니다. 테스트 코드를 먼저 작성하는 것부터 시작합니다.TDD는 3단계로 이루어져 있습니다. RED : 항상 실패하는 테스트를 작성하기 GREEN : 테스트가 통과하는 프로덕션 코드를 작성하기 REFACTOR : 테스트가 통과하면 프로덕션 코드를 리펙토링하기 단위 테스트TDD의 첫 번쨰 단계인 기능 단위의 테스트 코드를 작성하는 것을 이야기 합니다.TDD와 달리 테스트 코드를 꼭 먼저 작성해야 하는 것도 아니고 리팩토링도 포함되지 않습니다.순수하게 트스트 코드만 작성하는 것을 이야기합니다. 테스트 코드를 작성하는 이유 단위 테스트는 개발단계 초기에 문제를 발견하게 도와줍니다. 단위 테스트는 개발자가 나중에 코드를 리팩토링하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게 작동하는지 확일 할 수 있습니다. 단위 테스트는 기능에 대한 불확실성을 감소시킬 수 있습니다. 단위 테스트는 시스템에 대한 실제 문서를 제공합니다. 즉 단위 테스트 자체가 문서로 사용할 수 있습니다. 테스트 코드 작성하기main클레스 작성하기src/main/java 디렉토리에 패키지를 생성합니다.패키지 명은 웹 사이트 주소의 역순으로 합니다. ex) AAAA.BBBB.com(주소) &gt;&gt; com.BBBB.AAAA(패키지) 패키지 생성후 생성한 패키지에 Application이라는 Java클래스를 생성합니다.다음과 같이 코드를 작성해 봅시다. src/main/패키지명/Application1234567891011package 패키지명;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 방금 생성한 Application 클래스는 앞으로 만들 프로젝트의 메인 클래스가 됩니다.작성한 코드를 설명하자면@SpringBootApplication의 선언으로 인해 스프링 부트의 자동 설정, 스프링 Bean 읽기와 생성을 모두 자동으로 설정됩니다. 특히 @SpringBootApplication이 있는 위치부터 설정을 읽어 가기 때문에 이 클래스는 항상 프로젝트의 최상단에 위치해야만 합니다.main 메소드에서 SpringApplication.run으로 인해 내장 WAS를 실행합니다. 내장 WAS를 사용을 권장하는 이유‘언제 어디서나 같은 환경에서 스프링 부트를 배포’ 할수 있기 때문입니다.외장 WAS를 사용한다고 하면 모든 서버는 WAS의 종류와 버전, 설정등이 동일한 서버환경을 구축해야만 합니다. 만약 WAS의 버전을 올린다고하면 서버의 수가 적으면 괜찮지만 서버의 수가 많으면 실수할 여지가 늘어나게되고 시간이 많이 필요한 작업이 될 수도 있습니다. 방금 생성한 패키지 하위에 web이라는 패키지를 만들고 HelloController라는 Java클래스를 생성합니다.HelloController클래스에 다음과 같은 코드를 작성합니다. src/main/패키지명/web/HelloController1234567891011121314package 패키지명.web;import com.doop.book.springboot.web.dto.HelloResponseDto;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController { @GetMapping(&quot;hello&quot;) public String hello() { return &quot;hello&quot;; }} @RestController 컨트롤러를 JSON을 반환하는 컨트롤러로 만들어줍니다. 예전에는 @ResponseBody를 각 메소드마다 선언했던 것을 한번에 사용할 수 있게 해준다고 생각하면 됩니다. GetMapping Http Method인 Get의 요청을 받을 수 있는 API를 만들어 줍니다. 예전에는 @RequestMapping(method = RequestMethod.GET)으로 사용되었습니다. 이제 이 프로젝트는 /hello로 요청이 오면 문자열 hello를 반환하는 기능을 가지게 되었습니다. test 코드 작성하기src/test/java디렉토리에 패키지명.web패키지를 생성하고 테스트 코드를 작성할 HelloControllerTest클래스를 생성합니다.일반적으로 테스트 클래스는 대상 클래스 이름에 Test를 붙입니다.생성된 클래스에 다음과 같은 테스트 코드를 추가합니다. src/test/패키지명/web/HelloControllerTest12345678910111213141516171819202122232425262728import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringRunner.class)@WebMvcTest(controllers = HelloController.class)public class HelloControllerTest { @Autowired private MockMvc mvc; @Test public void hello가_리턴된다() throws Exception { String hello = &quot;hello&quot;; mvc.perform(get(&quot;/hello&quot;)) .andExpect(status().isOk()) .andExpect(content().string(hello)); }} @RunWith(SpringRunner.class) 테스트를 진행할 때 JUnit에 내장된 실행자 외에 다른 실행자를 실행시킵니다. 여기서는 SpringRunner라는 스프링 실행자를 사용합니다. 즉, 스프링 부트 테스트와 JUnit 사이에 연결자 역할을 합니다. @WebMvcTest 여러 스프링 테스트 어노테이션 중, Web(Spring MVC)에 집중할 수 있는 어노테이션 입니다. 선언할 경우 @Controller, @ControllerAdvice 등을 사용할 수 있습니다. 단, @Service, @Component, @Repository 등은 사용할 수 없습니다. 왜냐하면, 여기서는 컨트롤러만 사용하기 때문에 선언합니다. @Autowired 스프링이 관리하는 빈(Bean)을 주입 받습니다. private MockMvc mvc 웹 API를 테스트할 때 사용합니다. 스프링 MVC 테스트의 시작점입니다. 이 클래스를 통해 HTTP GET, POST 등에 대한 API 테스트를 할 수 있습니다. mvc.perform(get(“/hello”)) MockMvc를 통해 /hello 주소로 HTTP GET 요청을 합니다. 체이닝이 지원되어 아래와 같이 여러 검증 기능을 이어서 선언할 수 있습니다. .andExpect(status().isOk()) mvc.perform의 결과를 검증합니다. HTTP Header의 Statu를 검증합니다. 상태는 200, 404, 500 등의 상태를 검증합니다. 여기선 OK 즉, 200인지 아닌지 검증합니다. .andExpect(content().string(hello)); mvc.perform의 결과를 검증합니다. 응답 본문의 내용을 검증합니다. Controller에서 “hello”를 리턴하기 때문에 이 값이 맞는지 검증합니다. 코드를 모두 작성했다면, 테스트 코드를 한번 실행해봅시다.메소드 왼쪽의 초록색 화살표를 클릭합니다. 자바 롬복(Lombok)롬복(lombok) 은 자바 개발할 때 자주 사용하는 코드 Getter, Setter, 기본 생성자, toString 등을 어노테이션으로 자동 생성해줍니다. (자바 개발자들의 필수 라이브러리입니다.) 이클립스의 경우엔 롬복 설치가 번거롭지만, 인텔리제이에선 플러그인 덕분에 쉽게 설정이 가능합니다.우선 롬복을 사용하기 위해서 build.gradle 에서 dependencies영역 에 compile(‘org.projectlombok:lombok’)를 추가합니다. 설치build.gradle 의존성 추가12345dependencies { compile('org.springframework.boot:spring-boot-starter-web') compile('org.projectlombok:lombok') testCompile('org.springframework.boot:spring-boot-starter-test')} 롬복 플러그인 설치를 위해 Action(Ctrl + Shift + A) &gt;&gt; plugins 입력 하여 플러그인 설치 팝업 을 띄웁니다. marketplace 탭으로 이동하여 lombok을 검색하고 install 합니다. intelliJ를 재시작합니다. 재시작하면 오른쪽 하단에 롬복에 대한 설정이 필요하다라는 팝업이 뜨게되는데 파란색으로 표기된 설정 경로(Setting &gt; build &gt; Compiler &gt; Annotation Processors)를 클릭합니다. 경로로 들어가 Enable annotation processing을 체크 합니다. Hello Controller 코드 롬복으로 전환하기web패키지에 dto패키지를 추가합니다. 그리고 dto패키지에 HelloResponseDto를 생성합니다. src/main/패키지명/web/dto/HelloResponseDto123456789import lombok.Getter;import lombok.RequiredArgsConstructor;@Getter@RequiredArgsConstructorpublic class HelloResponseDto { private final String name; private final int amount;} @Getter 선언된 모든 필드의 get 메소드를 생성해 줍니다. @RequiredArgsConstructor 선언된 모든 final필드가 포함된 생성자를 생성해 줍니다. final이 없는 필드는 생성자에 포함되지 않습니다. Dto에 적용된 롬복이 잘 작동하는지 간단한 테스트 코드를 작성해봅시다. src/test/패키지명/web/dto/HelloResponseDtoTest12345678910111213141516171819import org.junit.Test;import static org.assertj.core.api.Assertions.assertThat;public class HelloResponseDtoTest { @Test public void 롬복_기능_테스트() { // given String name = &quot;test&quot;; int amount = 1000; // when HelloResponseDto dto = new HelloResponseDto(name, amount); // then assertThat(dto.getName()).isEqualTo(name); assertThat(dto.getAmount()).isEqualTo(amount); }} assertThat assertj라는 테스트 검증 라이브러리의 검증 메소드입니다. 검증하고 싶은 대상을 메소드 인자로 받습니다. 메소드 체이닝이 지원되어 isEqualTo와 같이 메소드를 이어서 사용할 수 있습니다. isEqualTo assertj의 동등 비교 메소드입니다. assertThat에 있는 값과 isEqualTo의 값을 비교해서 같을 때만 성공합니다. assertj의 장점Junit 과 비교하여 assertj의 장점은 다음과 같습니다. CoreMatchers와 달리 추가적으로 라이브러리가 필요하지 않습니다. Junit의 assertThat을 쓰게 되면 is()와 같이 CoreMatchers 라이브러리가 필요합니다. 자동완성이 좀 더 확실하게 지원도빈다. IDE에서는 CoreMatchers와 같은 Matcher 라이브러리의 자동완성 지원이 약합니다. 작성된 테스트 메소드를 실행해 봅니다.테스트 결과가 성공했다면, HelloController에 새로 만든 ResponseDto를 사용하도록 코드를 추가 합니다. 12345678910111213@RestControllerpublic class HelloController { @GetMapping(&quot;hello&quot;) public String hello() { return &quot;hello&quot;; } --추가하는 부분--- @GetMapping(&quot;/hello/dto&quot;) public HelloResponseDto helloDto(@RequestParam(&quot;name&quot;) String name,@RequestParam(&quot;amount&quot;) int amount) { return new HelloResponseDto(name, amount); }} @RequestParam 외부에서 API로 넘긴 파라미터를 가져오는 어노테이션입니다. 여기서는 외부에서 name(@RequestParam(“name”))이란 이름으로 넘긴 파라미터를 메소드 파라미터 name(String name)에 저장하게 됩니다. name과 amount는 API를 호출하는 곳에서 넘겨준 값들입니다. 추가된 API를 테스트 하는 코드를 HelloControllerTEst에 추가합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import static org.hamcrest.Matchers.is;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringRunner.class)@WebMvcTest(controllers = HelloController.class)public class HelloControllerTest { @Autowired private MockMvc mvc; @Test public void hello가_리턴된다() throws Exception { String hello = &quot;hello&quot;; mvc.perform(get(&quot;/hello&quot;)) .andExpect(status().isOk()) .andExpect(content().string(hello)); } @Test public void helloDto가_리턴된다() throws Exception { String name = &quot;hello&quot;; int amount = 1000; mvc.perform( get(&quot;/hello/dto&quot;) .param(&quot;name&quot;, name) // ...(1) .param(&quot;amount&quot;, String.valueOf(amount))) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$.name&quot;, is(name))) // ...(2) .andExpect(jsonPath(&quot;$.amount&quot;, is(amount))); }} param API 테스트할 때 사용될 요청 파라미터를 설정합니다. 단, 값은 String만 허용됩니다. 그래서 숫자/날짜 등의 데이터도 등록할 때는 문자열로 변경해야만 가능합니다. jsonPath JSON 응답값을 필드별로 검증할 수 있는 메소드입니다. $를 기준으로 필드명을 명시합니다. 여기서는 name과 amount를 검증하니 $.name, $.amount로 검증합니다.작성된 테스트 코드를 실행해 봅니다.","link":"/2021/01/09/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"}],"tags":[{"name":"hexo, 깃허브 블로그","slug":"hexo-깃허브-블로그","link":"/tags/hexo-%EA%B9%83%ED%97%88%EB%B8%8C-%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","slug":"스프링-부트와-AWS로-혼자-구현하는-웹-서비스","link":"/tags/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스, 테스트 코드","slug":"스프링-부트와-AWS로-혼자-구현하는-웹-서비스-테스트-코드","link":"/tags/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C/"}],"categories":[{"name":"test","slug":"test","link":"/categories/test/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"}]}