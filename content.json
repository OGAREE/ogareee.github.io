{"pages":[],"posts":[{"title":"TEST","text":"제목안녕하세요","link":"/2021/01/05/TEST/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/01/04/hello-world/"},{"title":"연습","text":"markdown 오늘 배운 내용 hexo markdown 오늘 만난 사람 오늘 생각한 아이디어 오늘은 markdown을 살짝 배웠어요!! 구글링 해서 찾아봐야지!!구글링하러 gogo!! 12345678910111213141516171819202122232425262728# markdown### 개요 ------TIL ( Today I Learned ) 블로그를 하는 목적- markdown ([총정리블로그](https://heropy.blog/2017/09/30/markdown/) ) &amp; vim 숙련- 잔디밭&lt;br&gt;#### 최근 들은 세션------1. 처음 시작하는 Git/Github 활용하기 ( OOS 개발자 포럼, 박희찬슈퍼 개발자님 ) [강의자료](https://bit.ly/git-starter)&lt;br&gt;#### 학습할자료------[슈퍼어메이징한터미널세팅](https://johngrib.github.io/wiki/my-mac-os-terminal/?fbclid=IwAR2QRRoeZv6L2sMbwmecLI5xJRObKmFHwxPmQ8OqR06w31Q8LcIpRijIfVs)[초보몽키개발공부로그](https://wayhome25.github.io/)[hexo적용한블로그태마깃헙](https://github.com/ppoffice/hexo-theme-icarus)[hexo적용한블로그사용법페이지](https://blog.zhangruipeng.me/hexo-theme-icarus/)[재원님disqus댓글기능추가하는방법](https://cresumerjang.github.io/2019/11/17/hexo-add-comments/?fbclid=IwAR0bHcNEprnoP1-28DVBkGq32MXaN_e4jGmhsF03XCNZsOgyzxj_aTkaHrU)&lt;br&gt;","link":"/2021/01/05/%EC%97%B0%EC%8A%B5/"},{"title":"1장. 스프링부트_시작하기","text":"* 스프링 부트와 AWS로 혼자 구현하는 웹 서비스(프리렉, 이동욱 지음)책을 통해 공부한 내용을 정리한 글입니다. * 목록 그레이들 프로젝트 변경 코드 설명 그레이들 프로젝트 변경먼저 intellij에서 gradle기반의 자바 프로젝트를 생성합니다.프로젝트 생성후 build.gradle 파일을 열어 보면 다음과 같은 코드가 있습니다. build.gradle 초기 상태12345678910111213141516plugins: { 'java'}group 'com.doop.book'version '1.0-SNAPSHOT'sourceCompatibility = 1.8repositories { mavenCentral()}dependencies { testCompile group: 'junit', name: 'junit', version: '4.12'} 이 코드들은 자바 개발에 가장 기초적인 설정만 되어있는 상태입니다. 이 코드에 스프링 부트에 필요한 설정들을 추가해 봅시다. build.gradle 수정후123456789101112131415161718192021222324252627282930buildscript { ext { springBootVersion = '2.1.7.RELEASE' } repositories { mavenCentral() jcenter() } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot;) }}apply plugin: 'java'apply plugin: 'eclipse'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management'group 'com.doop.book'version '1.0-SNAPSHOT'sourceCompatibility = 1.8repositories { mavenCentral()}dependencies { compile('org.springframework.boot:spring-boot-starter-web') testCompile('org.springframework.boot:spring-boot-starter-test')} 코드 설명123456789101112buildscript { ext { springBootVersion = '2.1.7.RELEASE' } repositories { mavenCentral() jcenter() } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot;) }} 이 코드는 프로젝트의 플러그인 의존성 관리를 위한 설정입니다.(인텔리제이의 플러그인 관리는 아님니다.)ext 라는 키워드는 build.gradle에서 사용하는 전역변수를 전역변수로 사용하겠다는 의미인데, 이 코드에서는 springBootVersion 라는 전역변수를 선언 후 값을 2.1.7.RELEASE로 하겠다는 의미입니다.classpath줄은 ‘spring-boot-gradle-plugin’ 라는 스프링 부트 그레이들 플러그인의 2.1.7.RELEASE를 의존성으로 받겠다는 의미입니다. 1234apply plugin: 'java'apply plugin: 'eclipse'apply plugin: 'org.springframework.boot'apply plugin: 'io.spring.dependency-management' 위의 플러그인 4개는 자바와 스프링 부트를 사용하기 위한 필수 플러그인입니다.io.spring.dependency.management 플러그인은 스프링 부트의 의존성을 관리해 주는 플러그인이라 꼭 추가해야 합니다. 123456789repositories { mavenCentral() jcenter()}dependencies { compile('org.springframework.boot:spring-boot-starter-web') testCompile('org.springframework.boot:spring-boot-starter-test')} repositories 각종 의존성(라이브러리)들을 어떤 원격 저장소에서 받을지를 정합니다. 기본적으로 mavenCentral을 많이 사용하지만, 최근에는 라이브러리 업로드 난이도 때문에 jcenter도 많이 사용합니다. dependencies 프로젝트 개발에 필요한 의존성들을 선언하는 곳입니다. 인텔리제이는 메이븐 저장소의 데이터를 인덱싱해서 관리하기 때문에 의존성 자동완성이 가능합니다. complie 메소드 안에 라이브러리의 이름의 앞부분만 추가한 뒤 자동완성(Ctrl+Space) 을 사용하면 라이브러리 목록을 확인 할 수 있습니다. 의존성 코드는 직접 작성해도 되고, 자동완성으로 작성해도 됩니다. 단, 특정 버전을 명시하면 안 됩니다. 왜냐하면 버전을 명시하지 않아야만 맨위에 작성한 org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion} 의 버전을 따라가게 됩니다. build.gradle에 반영하기코드 설정이 끝이나면 오른쪽 하단에 Event Log에서 build.gradle에 변경이 있으니 반영하라 라는 알람이 나옵니다.[Import Changes]는 1회 변경을 허용하는 것이고, [Enable Auto-Import]는 수정될때 마다 자동으로 반영이 되는 것입니다.(필자는 이것이 나오지 않아 수동으로 반영하였다.) build 적용이 안될 시오류가 뜬다면 gradle의 버전을 확인해 봅시다.터미널에 다음과 같은 명령어를 치면 그레이들의 버전을 확인할수 있습니다. 1gradlew --version 버전이 5.x.x라면 4.x.x 로 바꾸어 줍니다. 1gradlew wrapper --gradle-version 4.10.2","link":"/2021/01/06/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"2장. 스프링_부트에스_테스트_코드_작성하기","text":"* 스프링 부트와 AWS로 혼자 구현하는 웹 서비스(프리렉, 이동욱 지음)책을 통해 공부한 내용을 정리한 글입니다. * 목록 TDD와 단위 테스트 TDD 단위 테스트 테스트 코드를 작성하는 이유 테스트 코드 작성하기 main 클래스 작성하기 내장 WAS를 사용을 권장하는 이유 test 코드 작성하기 자바 롬복(Lombok) 설치 Hello Controller 코드 롬복으로 전환하기 assertj의 장점 TDD와 단위 테스트TDD테스트가 주도하는 개발을 이야기합니다. 테스트 코드를 먼저 작성하는 것부터 시작합니다.TDD는 3단계로 이루어져 있습니다. RED : 항상 실패하는 테스트를 작성하기 GREEN : 테스트가 통과하는 프로덕션 코드를 작성하기 REFACTOR : 테스트가 통과하면 프로덕션 코드를 리펙토링하기 단위 테스트TDD의 첫 번쨰 단계인 기능 단위의 테스트 코드를 작성하는 것을 이야기 합니다.TDD와 달리 테스트 코드를 꼭 먼저 작성해야 하는 것도 아니고 리팩토링도 포함되지 않습니다.순수하게 트스트 코드만 작성하는 것을 이야기합니다. 테스트 코드를 작성하는 이유 단위 테스트는 개발단계 초기에 문제를 발견하게 도와줍니다. 단위 테스트는 개발자가 나중에 코드를 리팩토링하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게 작동하는지 확일 할 수 있습니다. 단위 테스트는 기능에 대한 불확실성을 감소시킬 수 있습니다. 단위 테스트는 시스템에 대한 실제 문서를 제공합니다. 즉 단위 테스트 자체가 문서로 사용할 수 있습니다. 테스트 코드 작성하기main클레스 작성하기src/main/java 디렉토리에 패키지를 생성합니다.패키지 명은 웹 사이트 주소의 역순으로 합니다. ex) AAAA.BBBB.com(주소) &gt;&gt; com.BBBB.AAAA(패키지) 패키지 생성후 생성한 패키지에 Application이라는 Java클래스를 생성합니다.다음과 같이 코드를 작성해 봅시다. src/main/패키지명/Application1234567891011package 패키지명;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 방금 생성한 Application 클래스는 앞으로 만들 프로젝트의 메인 클래스가 됩니다.작성한 코드를 설명하자면@SpringBootApplication의 선언으로 인해 스프링 부트의 자동 설정, 스프링 Bean 읽기와 생성을 모두 자동으로 설정됩니다. 특히 @SpringBootApplication이 있는 위치부터 설정을 읽어 가기 때문에 이 클래스는 항상 프로젝트의 최상단에 위치해야만 합니다.main 메소드에서 SpringApplication.run으로 인해 내장 WAS를 실행합니다. 내장 WAS를 사용을 권장하는 이유‘언제 어디서나 같은 환경에서 스프링 부트를 배포’ 할수 있기 때문입니다.외장 WAS를 사용한다고 하면 모든 서버는 WAS의 종류와 버전, 설정등이 동일한 서버환경을 구축해야만 합니다. 만약 WAS의 버전을 올린다고하면 서버의 수가 적으면 괜찮지만 서버의 수가 많으면 실수할 여지가 늘어나게되고 시간이 많이 필요한 작업이 될 수도 있습니다. 방금 생성한 패키지 하위에 web이라는 패키지를 만들고 HelloController라는 Java클래스를 생성합니다.HelloController클래스에 다음과 같은 코드를 작성합니다. src/main/패키지명/web/HelloController1234567891011121314package 패키지명.web;import com.doop.book.springboot.web.dto.HelloResponseDto;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController { @GetMapping(&quot;hello&quot;) public String hello() { return &quot;hello&quot;; }} @RestController 컨트롤러를 JSON을 반환하는 컨트롤러로 만들어줍니다. 예전에는 @ResponseBody를 각 메소드마다 선언했던 것을 한번에 사용할 수 있게 해준다고 생각하면 됩니다. GetMapping Http Method인 Get의 요청을 받을 수 있는 API를 만들어 줍니다. 예전에는 @RequestMapping(method = RequestMethod.GET)으로 사용되었습니다. 이제 이 프로젝트는 /hello로 요청이 오면 문자열 hello를 반환하는 기능을 가지게 되었습니다. test 코드 작성하기src/test/java디렉토리에 패키지명.web패키지를 생성하고 테스트 코드를 작성할 HelloControllerTest클래스를 생성합니다.일반적으로 테스트 클래스는 대상 클래스 이름에 Test를 붙입니다.생성된 클래스에 다음과 같은 테스트 코드를 추가합니다. src/test/패키지명/web/HelloControllerTest12345678910111213141516171819202122232425262728import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringRunner.class)@WebMvcTest(controllers = HelloController.class)public class HelloControllerTest { @Autowired private MockMvc mvc; @Test public void hello가_리턴된다() throws Exception { String hello = &quot;hello&quot;; mvc.perform(get(&quot;/hello&quot;)) .andExpect(status().isOk()) .andExpect(content().string(hello)); }} @RunWith(SpringRunner.class) 테스트를 진행할 때 JUnit에 내장된 실행자 외에 다른 실행자를 실행시킵니다. 여기서는 SpringRunner라는 스프링 실행자를 사용합니다. 즉, 스프링 부트 테스트와 JUnit 사이에 연결자 역할을 합니다. @WebMvcTest 여러 스프링 테스트 어노테이션 중, Web(Spring MVC)에 집중할 수 있는 어노테이션 입니다. 선언할 경우 @Controller, @ControllerAdvice 등을 사용할 수 있습니다. 단, @Service, @Component, @Repository 등은 사용할 수 없습니다. 왜냐하면, 여기서는 컨트롤러만 사용하기 때문에 선언합니다. @Autowired 스프링이 관리하는 빈(Bean)을 주입 받습니다. private MockMvc mvc 웹 API를 테스트할 때 사용합니다. 스프링 MVC 테스트의 시작점입니다. 이 클래스를 통해 HTTP GET, POST 등에 대한 API 테스트를 할 수 있습니다. mvc.perform(get(“/hello”)) MockMvc를 통해 /hello 주소로 HTTP GET 요청을 합니다. 체이닝이 지원되어 아래와 같이 여러 검증 기능을 이어서 선언할 수 있습니다. .andExpect(status().isOk()) mvc.perform의 결과를 검증합니다. HTTP Header의 Statu를 검증합니다. 상태는 200, 404, 500 등의 상태를 검증합니다. 여기선 OK 즉, 200인지 아닌지 검증합니다. .andExpect(content().string(hello)); mvc.perform의 결과를 검증합니다. 응답 본문의 내용을 검증합니다. Controller에서 “hello”를 리턴하기 때문에 이 값이 맞는지 검증합니다. 코드를 모두 작성했다면, 테스트 코드를 한번 실행해봅시다.메소드 왼쪽의 초록색 화살표를 클릭합니다. 자바 롬복(Lombok)롬복(lombok) 은 자바 개발할 때 자주 사용하는 코드 Getter, Setter, 기본 생성자, toString 등을 어노테이션으로 자동 생성해줍니다. (자바 개발자들의 필수 라이브러리입니다.) 이클립스의 경우엔 롬복 설치가 번거롭지만, 인텔리제이에선 플러그인 덕분에 쉽게 설정이 가능합니다.우선 롬복을 사용하기 위해서 build.gradle 에서 dependencies영역 에 compile(‘org.projectlombok:lombok’)를 추가합니다. 설치build.gradle 의존성 추가12345dependencies { compile('org.springframework.boot:spring-boot-starter-web') compile('org.projectlombok:lombok') testCompile('org.springframework.boot:spring-boot-starter-test')} 롬복 플러그인 설치를 위해 Action(Ctrl + Shift + A) &gt;&gt; plugins 입력 하여 플러그인 설치 팝업 을 띄웁니다. marketplace 탭으로 이동하여 lombok을 검색하고 install 합니다. intelliJ를 재시작합니다. 재시작하면 오른쪽 하단에 롬복에 대한 설정이 필요하다라는 팝업이 뜨게되는데 파란색으로 표기된 설정 경로(Setting &gt; build &gt; Compiler &gt; Annotation Processors)를 클릭합니다. 경로로 들어가 Enable annotation processing을 체크 합니다. Hello Controller 코드 롬복으로 전환하기web패키지에 dto패키지를 추가합니다. 그리고 dto패키지에 HelloResponseDto를 생성합니다. src/main/패키지명/web/dto/HelloResponseDto123456789import lombok.Getter;import lombok.RequiredArgsConstructor;@Getter@RequiredArgsConstructorpublic class HelloResponseDto { private final String name; private final int amount;} @Getter 선언된 모든 필드의 get 메소드를 생성해 줍니다. @RequiredArgsConstructor 선언된 모든 final필드가 포함된 생성자를 생성해 줍니다. final이 없는 필드는 생성자에 포함되지 않습니다. Dto에 적용된 롬복이 잘 작동하는지 간단한 테스트 코드를 작성해봅시다. src/test/패키지명/web/dto/HelloResponseDtoTest12345678910111213141516171819import org.junit.Test;import static org.assertj.core.api.Assertions.assertThat;public class HelloResponseDtoTest { @Test public void 롬복_기능_테스트() { // given String name = &quot;test&quot;; int amount = 1000; // when HelloResponseDto dto = new HelloResponseDto(name, amount); // then assertThat(dto.getName()).isEqualTo(name); assertThat(dto.getAmount()).isEqualTo(amount); }} assertThat assertj라는 테스트 검증 라이브러리의 검증 메소드입니다. 검증하고 싶은 대상을 메소드 인자로 받습니다. 메소드 체이닝이 지원되어 isEqualTo와 같이 메소드를 이어서 사용할 수 있습니다. isEqualTo assertj의 동등 비교 메소드입니다. assertThat에 있는 값과 isEqualTo의 값을 비교해서 같을 때만 성공합니다. assertj의 장점Junit 과 비교하여 assertj의 장점은 다음과 같습니다. CoreMatchers와 달리 추가적으로 라이브러리가 필요하지 않습니다. Junit의 assertThat을 쓰게 되면 is()와 같이 CoreMatchers 라이브러리가 필요합니다. 자동완성이 좀 더 확실하게 지원도빈다. IDE에서는 CoreMatchers와 같은 Matcher 라이브러리의 자동완성 지원이 약합니다. 작성된 테스트 메소드를 실행해 봅니다.테스트 결과가 성공했다면, HelloController에 새로 만든 ResponseDto를 사용하도록 코드를 추가 합니다. 12345678910111213@RestControllerpublic class HelloController { @GetMapping(&quot;hello&quot;) public String hello() { return &quot;hello&quot;; } --추가하는 부분--- @GetMapping(&quot;/hello/dto&quot;) public HelloResponseDto helloDto(@RequestParam(&quot;name&quot;) String name,@RequestParam(&quot;amount&quot;) int amount) { return new HelloResponseDto(name, amount); }} @RequestParam 외부에서 API로 넘긴 파라미터를 가져오는 어노테이션입니다. 여기서는 외부에서 name(@RequestParam(“name”))이란 이름으로 넘긴 파라미터를 메소드 파라미터 name(String name)에 저장하게 됩니다. name과 amount는 API를 호출하는 곳에서 넘겨준 값들입니다. 추가된 API를 테스트 하는 코드를 HelloControllerTEst에 추가합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import static org.hamcrest.Matchers.is;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringRunner.class)@WebMvcTest(controllers = HelloController.class)public class HelloControllerTest { @Autowired private MockMvc mvc; @Test public void hello가_리턴된다() throws Exception { String hello = &quot;hello&quot;; mvc.perform(get(&quot;/hello&quot;)) .andExpect(status().isOk()) .andExpect(content().string(hello)); } @Test public void helloDto가_리턴된다() throws Exception { String name = &quot;hello&quot;; int amount = 1000; mvc.perform( get(&quot;/hello/dto&quot;) .param(&quot;name&quot;, name) // ...(1) .param(&quot;amount&quot;, String.valueOf(amount))) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$.name&quot;, is(name))) // ...(2) .andExpect(jsonPath(&quot;$.amount&quot;, is(amount))); }} param API 테스트할 때 사용될 요청 파라미터를 설정합니다. 단, 값은 String만 허용됩니다. 그래서 숫자/날짜 등의 데이터도 등록할 때는 문자열로 변경해야만 가능합니다. jsonPath JSON 응답값을 필드별로 검증할 수 있는 메소드입니다. $를 기준으로 필드명을 명시합니다. 여기서는 name과 amount를 검증하니 $.name, $.amount로 검증합니다.작성된 테스트 코드를 실행해 봅니다.","link":"/2021/01/09/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"},{"title":"3장. 스프링부트에서 JPA로 데이터베이스 다루기","text":"* 스프링 부트와 AWS로 혼자 구현하는 웹 서비스(프리렉, 이동욱 지음)책을 통해 공부한 내용을 정리한 글입니다. * 목록 JPA소개 프로젝트에 Spring Data Jpa 적용하기 Spring Data JPA 테스트 코드 작성하기 등록/수정/조회 API 만들기 JPA Audtiting을 이용한 등록/수정 시간 자동화 JPA 소개&nbsp;현대의 웹 애플리케이션에서 관계형 데이터베이스(RDB, Relational Database) 는 빠질 수 없는 요소입니다.Oracle, MySQL, MSSQL등을 쓰지 않는 웹 애플리케이션은 거의 없습니다. 그러다 보니 객체를 관계형 데이터 베이스에서 관리하는 것이 무엇보다 중요합니다. &nbsp;관계형 데이터 베이스가 계속해서 웹 서비스의 중심이 되면서 모든 코드는 SQL중심이 되어갑니다.관계형 데이터 베이스는 SQL만 인식할 수 있기 때문입니다.SQL로만 가능하니 각 테이블마다 기본적인 CRUD(Create, Read, Update, Delete)SQL을 매번 생성해야 합니다. 개발자가 아무리 자바 클래스를 아름답게 설계해도, SQL을 통해야만 데이터 베이스에 저장하고 조회할 수 있습니다. 관계형 데이터 베이스를 사용해야만 하는 상황에서 SQL은 피할 수 없습니다. 즉, 테이블의 수가 많을 수록 단순 반복 작업이 늘어난다는 것입니다. 이런 단순 반복 작업의 문제 외에도 패러다임 불일치문제가 있습니다. 관계형 데이터 베이스는 어떻게 데이터를 저장할지에 초점이 맞춰진 기술입니다. 반대로 객체지향 프로그래밍 언어는 메시지를 기반으로 기능과 속성을 한 곳에서 관리하는 기술입니다.관계형 데이터 베이스와 객체지향 프로그래밍 언어의 패러다임이 다른데, 객체를 데이터 베이스에 저장하려고 하니 여러 문제가 발생합니다. 이를 패러다임 불일치라고 합니다. 객체지향 프로그래밍에서 부모가 되는 개체를 가져오기12User user = findUser();Group group = user.getGroup(); User와 Group은 부모-자식 관계임을 알 수 있다. 위의 코드에 데이터베이스를 추가12User user = userDao.findUser();Group group = groupDao.findGroup(user.getGroupId()); &nbsp;데이터베이스가 추가된 경우엔 User 따로, Group 따로 조회하게 됩니다.User와 Group이 어떤 관계 인지 알 수 있을까요?상속, 1:N 등 객체 모델링을 데이터베이스로는 구현할 수 없습니다. 그러다 보니 웹 애플리케이션 개발은 데이터 베이스 모델링에만 집중 하게 됩니다.JPA는 이런 문제점을 해결하기 위해 등장하게 됩니다. JPA는 서로 지향하는 바가 다른 2개의 영역(객체지향 - 관계형 데이터베이스)을 중간에서 패러다임 일치를 시켜 주기 위한 기술이다. 즉, 개발자는 객체지향적으로 프로그래밍을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성 해서 실행합니다. 개발자는 항상 객체지향적으로 코드를 표현할 수 있으니 더는 SQL에 종속적인 개발을 하지 않아도 됩니다. Spring Data JPA&nbsp;JPA는 인터페이스로서 자바 표준명세서입니다. 인터페이스인 JPA를 사용하기 위해서는 구현체가 필요합니다. 대표적으로 Hibernate, Eclipse, Link 등이 있습니다. 하지만 Spring에서 JPA를 사용할 때는 이 구현체들을 직접 다루진 않고 구현체들을 좀 더 쉽게 사용하고자 추상화시킨 Spring Data JPA라는 모듈을 이용하여 JPA기술을 다룹니다.이들의 관계를 다음과 같이 나타낼 수 있습니다. JPA ← Hibernate ← Spring Data JPA &nbsp;Hibernate 와 Spring Data JPA 은 서로 큰 차이가 없습니다. 그럼에도 스프링 진영에서는 Spring Data JPA를 개발했고, 이를 권장하고 있습니다.&nbsp;이렇게 한 단계 더 감싸놓은 Spring Data JPA가 등장한 이유는 크게 두가지가 있습니다. 구현체 교체의 용이성 저장소 교체의 용이성 &nbsp;‘구현체 교체의 용이성’**이란 **Hibernate 외에 다른 구현체로 쉽게 교체하기 위함입니다. Spring Data JPA 내부에서 구현체 매핑을 지원해주기 때문에 교체가 용이합니다. &nbsp;저장소 교체의 용이성이란 관계형 데이터베이스 외에 다른 저장소로 쉽게 교체하기 위함입니다. 서비스 초기에는 관계형 데이터베이스로 모든 기능을 처리했지만, 트래픽이 많아지면서 관계형 데이터베이스로는 감당이 안될 때가 올 수 있습니다. 이때 MongoDB로 교체가 필요하다면 개발자는 Spring Data JPA에서 Spring Data MongoDB로 의존성만 교체 하면 됩니다. &nbsp;이는 Spring Data의 하위 프로젝트들은 기본적인 CRUD의 인터페이스가 같기 때문입니다. 이런 장점들로 인해 Hibernate 보다는 Spring Data를 권장하고 있습니다. 프로젝트에 Spring Data Jpa 적용하기먼저 build.gradle에 다음과 같이 org.springframework.boot:spring-boot-starter-data-jpa와 com.h2database:h2의존성을 등록합니다. 123456789dependencies { compile('org.springframework.boot:spring-boot-starter-web') compile('org.projectlombok:lombok') --추가 부분-- compile('org.springframework.boot:spring-boot-starter-data-jpa') compile('com.h2database:h2') ------------ testCompile('org.springframework.boot:spring-boot-starter-test')} @spring-boot-starter-data-jpa 스프링 부트용 Spring Data Jpa추상화 라이브러리 입니다. 스프링 부트 버전에 맞춰 자동으로 JPA관련 라이브러리들의 버전을 관리해줍니다. h2 인메모리 관계형 데이터베이스입니다. 별도의 설치가 필요 없이 프로젝트 의존성만으로 관리할 수 있습니다. 메모리에서 실행되기 때문에 애플리케이션을 재시작할 때마다 초기화된다는 점을 이용하여 테스트 용도로 많이 사용됩니다. &nbsp;의존성이 등록되었다면, 본격적으로 JPA기능을 사용해 보겠습니다.com.BBBB.AAAA패키지 아래 domain이라는 패키지를 만들어줍니다.이 domain패키지는 도메인을 담을 패키지입니다. &nbsp;도메인이란 게시글, 댓글, 회원, 정산, 결제 등 소프트웨어에 대한 요구사항 혹은 문제 영역이라고 생각하면됩니다. 기존에 MyBatis와 같은 쿼리 매퍼를 사용했다면 dao 패키기를 떠올리겠지만, dao 패키지와는 조금 결이 다르다고 생각하면 됩니다. 그간 xml에 쿼리를 담고, 클래스는 오로지 쿼리의 결과만 담던 일들이 모두 도메인 클래스라고 불리는 곳에서 해결됩니다. domain 패키지아래에 posts패키지와 Posts클래스를 만듭니다. sr/main/java/패키지명/domain/posts/Post123456789101112131415161718192021222324252627282930import lombok.Builder;import lombok.Getter;import lombok.NoArgsConstructor;import javax.persistence.*;@Getter@NoArgsConstructor @Entity public class Posts { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(length = 500, nullable = false) private String title; @Column(columnDefinition = &quot;TEXT&quot;, nullable = false) private String content; private String author; @Builder public Posts(String title, String content, String author) { this.title = title; this.content = content; this.author = author; }} @Entity 테이블과 링크될 클래스임을 나타냅니다. 기본값으로 클래스의 카멜케이스 이름을 언더스코어 네이밍(_)으로 테이블 이름을 매칭합니다. ex) SalesManager.java → sales_manager table @Id 해당 테이블의 PK필드를 나타냅니다. @GeneratedValue PK의 생성 규칙을 나타냅니다. 스프링 부트 2.0에서는 GenerationType.IDENTITY 옵션을 추가해야만 auto_increment가 됩니다. @Column 테이블의 칼럼을 나타내며 굳이 선언하지 않더라도 해당 클래스의 필드는 모두 칼럼이 됩니다. 사용하는 이유는, 기본값 외에 추가로 변경이 필요한 옵션이 있으면 사용합니다. 문자열의 경우 VARCHAR(255)가 기본값인데, 사이즈를 500으로 늘리고 싶거나 (ex: title), 타입을 TEXT로 변경하고 싶거나(ex: content) 등의 경우에 사용됩니다. @NoArgsConstructor 기본 생성자 자동 추가 public Posts() {}와 같은 효과 @Getter 클래스 내 모든 필드의 Getter 메소드를 자동생성 @Builder 해당 클래스의 빌더 패턴 클래스를 생성 생성자 상단에 선언 시 생성자에 포함된 필드만 빌더에 포함 참고 Entity의 PK는 Long 타입의 Auto_increament를 추천합니다. 이유는 주민등록번호와 같이 비즈니스상 유니크 키나, 여러 키를 조합한 복합키로 PK를 잡을 경우 1.FK를 맺을 때 다른 테이블에서 복한키 전부를 갖고 있거나, 중간 테이블을 하나 더 둬야 하는 상황이 발생합니다. 2.인덱스에 좋은 영향을 끼치지 못합니다. 3.유니크한 조건이 변경될 경우 PK 전체를 수정해야 하는 일이 발생합니다. 주민등록번호, 복합키 등은 유니크 키로 별도로 추가하는 것을 추천합니다. 이 Posts클래스에는 한 가지 특이점이 있브니다. 바로 Setter메소드가 없다는 점입니다. Entity 클래스에서는 절대 Setter 메소드를 만들지 않습니다. 이유는 해당 클래스의 인스턴스 값들이 언제 어디서 변해야 하는지 코드상으로 명확하게 구분할 수가 없어, 차후 기능 변경 시 정말 복잡해지기 때문입니다. 대신, 해당 필드의 값 변경이 필요하면 명확히 그 목적과 의도를 나타낼 수 있는 메소드를 추가해야만 합니다. 잘못된 사용 예12345678public class Order{ public void setStatus(boolean status){ this.status = status; }}public void 주문서비스의_취소이벤트(){ order.setStatus(false);} 올바른 사용 예12345678public class Order{ public void cancelOrder(){ this.status = false; }}public void 주문서비스의_취소이벤트(){ order.cancelOrder();} Setter가 없는 상황에서 어떻게 값을 채워 DB에 삽입 해야할까요? 기본적인 구조는 생성자를 통해 최종값을 채운 후 DB에 삽입 하는 것 이며, 값 변경이 필요한 경우 해당 이벤트에 맞는 public 메소드를 호출하여 변경 하는 것을 전제로 합니다. 또 다른 방법으로는 @Builder를 통해 제공되는 빌더 클래스를 사용하는 것이다. 생성자나 빌더나 생성 시점에 값을 채워주는 역할은 똑같습니다. 다만, 생성자의 경우 지금 채워야 할 필드가 무엇인지 명확히 지정할 수 가 없습니다. 예를 들어 다음과 같은 코드가 있을 때 1234public Example(String a, String b) { this.a = a; this.b = b;} new Example(b, a)처럼 a와b의 위치를 변경해도 코드를 실행하기 전까지는 문제를 찾을 수가 없습니다.하지만 빌더를 사용하게 되면 다음과 같이 어느 필드에 어떤 값을 채워야 할지 명확하게 인지 할 수 있습니다. 1234Example.builder() .a(a) .b(b) .build(); Posts 클래스 생성이 끝났다면, Posts클래스로 Databas를 접근하게 해줄 JpaRepository를 생성합니다. src/main/java/패키지명/domain/posts/PostsRepository12345import org.springframework.data.jpa.repository.JpaRepository;public interface PostsRepository extends JpaRepository&lt;Posts, Long&gt; {} &nbsp;보통 ibatis나 MyBatis 등에서 Dao라고 불리는 DB layer접근자 입니다. JPA에선 Repository라고 부르며 인터페이스로 생성 합니다.단순히 인터페이스를 생성후, JpaRepository&lt;Entity 클래스, PK타입&gt;를 상속하면 기본적인 CRUD메소드가 자동으로 생성됩니다.@Repository를 추가할 필요도 없습니다. 주의할점 Entity클래스와 기본 Entity Repository는 함께 위치 해야 한다. Entity 클래스는 기본 Repository 없이는 제대로 역할을 할 수가 없습니다. Entity클래스와 기본 Repository는 함께 움직여야 하므로 도메인 패키지에서 함께 관리합니다. Spring Data JPA 테스트 코드 작성하기test디렉토리에 domain.posts패키지를 생성 후 PostsRepositoryTest클래스를 생성합니다. src/test/java/패키지명/domain/posts/PostsRepositoryTest123456789101112131415161718192021222324252627282930313233343536373839404142import org.junit.After;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;import static org.assertj.core.api.Assertions.assertThat;@RunWith(SpringRunner.class)@SpringBootTestpublic class PostsRepositoryTest { @Autowired PostsRepository postsRepository; @After public void cleanup() { postsRepository.deleteAll(); } @Test public void 게시글저장_불러오기() { // given String title = &quot;테스트 게시글&quot;; String content = &quot;테스트 본문&quot;; postsRepository.save(Posts.builder() .title(title) .content(content) .author(&quot;ㅁㅁㅁㅁ@gmail.com&quot;) .build()); // when List&lt;Posts&gt; postsList = postsRepository.findAll(); Posts posts = postsList.get(0); assertThat(posts.getTitle()).isEqualTo(title); assertThat(posts.getContent()).isEqualTo(content); }} @After Junit에서 단위 테스트가 끝날 때마다 수행되는 메소드를 지정 보통은 배포 전 전체 테스트를 수행할 때 테스트간 데이터 침범을 막기 위해 사용합니다. 여러 테스트가 동시에 수행되면 테스트용 데이터베이스인 H2에 데이터가 그대로 남아 있어 다음 테스트 실행 시 테스트가 실패할 수 있습니다. postsRepository.save 테이블 posts에 insert/update 쿼리를 실행합니다 id 값이 있다면 update가, 없다면 insert 쿼리가 실행됩니다. postsRepository.findAll 테이블 posts에 있는 모든 데이터를 조회해오는 메소드입니다. 별다른 설정 없이 @SpringBootTest를 사용할 경우 H2 데이터베이스를 자동으로 실행해 줍니다. 실행된 쿼리를 로그로 출력만약 실제로 실행된 쿼리를 로그 형태로 보고싶다면 src/main/resources 디렉토리 아래 application.properties파일을 생성 하고 spring.jpa.show_sql=true를 작성 후 실행하면 됩니다. 출력되는 형태는 H2 문법이 적용된 로그입니다. 출력되는 쿼리 로그를 MySQL버전으로 변경하고싶다면 spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.MySQL5InnoDBDialect 코드를 추가하면 된다. 등록/수정/조회 API 만들기API를 만들기 위해 총 3개의 클래스가 필요합니다. Request 데이터를 받을 Dto API 요청을 받을 Controller 트랜잭션, 도메인 기능 간의 순서를 보장하는 Service 여기서 많은 분들이 오해하고 계신 것이, Service에서 비지니스 로직을 처리해야 한다는 것입니다. 하지만 전혀 그렇지 않습니다. Service는 트랜잭션, 도메인 간 순서 보장의 역할만 합니다. 비지니스 로직을 처리하는 영역은 아래서 설명하겠습니다. Spring 웹 계층 각 영역을 소개하자면 다음과 같습니다. Web Layer 흔히 사용하는 컨트롤러(@Controller)와 JSP/Freemarker 등의 뷰 템플릿 영역입니다. 이외에도 필터(@Filter), 인터셉터, 컨트롤러 어드바이스(@ControllerAdvice)등 외부 요청과 응답에 대한 전반적인 영역을 이야기합니다. Service Layer @Service에 사용되는 서비스 영역입니다. 일반적으로 Controller와 Dao의 중간 영역에서 사용됩니다. @Transactional이 사용되어야 하는 영역이기도 합니다. Repository Layer Database와 같이 데이터 저장소에 접근하는 영역입니다. 기존에 개발하셨던 분들이라면 Dao(Data Access Object)영역으로 이해하시면 쉬울 것입니다. Dtos Dto(Data Transfer Object)는 계층 간에 데이터 교환을 위한 객체를 이야기하며 Dtos는 이들의 영역 을 얘기합니다. 예를 들어 뷰 템플릿 엔진에서 사용될 객체나 Repository Layer에서 결과로 넘겨준 객체 등이 이들을 이야기합니다. Domain Model 도메인이라 불리는 개발 대상을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화시킨 것을 도메인 모델이라고 합니다. 이를테면 택시 앱이라고 하면 배차, 탑승, 요금 등이 모두 도메인이 될 수 있습니다. @Entity를 사용해보신 분들은 @Entity가 사용된 영역 역시 도메인 모델이라고 이해하면 됩니다. 다만, 무조건 데이터베이스의 테이블과 관계가 있어야만 하는 것은 아닙니다. VO처럼 값 객체들도 이 영역에 해당하기 때문입니다. Web(controller), Service, Repository, Dto, Domain, 이 5가지 레이어에서 비지니스 처리를 담당해야 할 곳은 Domain입니다. 기존에 서비스로 처리하던 방식을 트랜잭션 스크립트라고 합니다. 모든 로직이 서비스 클래스 내부에서 처리됩니다. 그러다 보니 서비스 계층이 무의미하며, 객체란 단순히 데이터 덩어리역활만 하게 됩니다. 반면 도메인 모델에서 처리할 경우 서비스 메소드는 트랜잭션과 도메인 간의 순서만 보장해 줍니다. 코드 작성이제 등록, 수정, 삭제 기능을 만들어 보겠습니다. web패키지에 PostsApiController, web.dto패키지에 PostsSaveRequestDto, service.posts패키지에 PostsService를 생성합니다. src/main/java/패키지명/web/PostsApiController12345678910111213141516import lombok.RequiredArgsConstructor;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;@RequiredArgsConstructor@RestControllerpublic class PostsApiController { private final PostsService postsService; @PostMapping(&quot;/api/v1/posts&quot;) public Long save(@RequestBody PostsSaveRequestDto requestDto) { return postsService.save(requestDto); }} src/main/java/패키지명/service/PostsService1234567891011121314151617181920212223242526272829import lombok.RequiredArgsConstructor;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@RequiredArgsConstructor@Servicepublic class PostsService { private final PostsRepository postsRepository; @Transactional public Long save(PostsSaveRequestDto requestDto){ return postsRepository.save(requestDto.toEntity()).getId(); } @Transactional public Long update(Long id, PostsUpdateRequestDto requestDto){ Posts posts = postsRepository.findById(id) .orElseThrow(()-&gt; new IllegalArgumentException(&quot;해당 게시글이 없습니다. id=&quot;+id)); posts.update(requestDto.getTitle(), requestDto.getContent()); return id; } public PostsResponseDto findById(Long id){ Posts entity = postsRepository.findById(id) .orElseThrow(()-&gt; new IllegalArgumentException(&quot;해당 게시글이 없습니다. id=&quot;+id)); return new PostsResponseDto(entity); }} Controller와 Service 코드를 살펴보면 @Autowired가 없는 것을 볼 수 있다. 스프링에서 Bean 주입 방식에는 3가지가 있다. @Autowired setter 생성자 이 중에서 가장 권장하는 방식이 생성자로 주입받는 방식입니다.(@Autowired는 권장하지 않습니다.)즉, 생성자로 Bean객체를 받도록 하면 @Autowired와 동일한 효과를 볼 수 있다는 것입니다.위 코드에서는 생성자로 Bean을 주입 하는 부분이 없지만 @RequiredArgsConstructor가 해결해 줍니다. @RequiredArgsConstructor는 final로 선언된 모든 필드를 인자값으로 하는 생성자를롬복의 @RequiredArgsConstructor가 대신 생성해 준 것입니다. 생성자를 직접 안 쓰고 롬복 @RequiredArgsConstructor를 사용한 이유해당 클래스의 의존성 관계가 변경될 때마다 생성자 코드를 계속해서 수정하는 번거로움을 해결하기 위함입니다. 롬복 어노테이션이 있으면 해달 컨트롤러에 새로운 서비스를 추가하거나, 기존 컴포넌트를 제거하는 등의 상황이 발생해도 생성자 코드는 전혀 손대지 않아도 됩니다. 이제는 Controller와 Service에서 사용할 Dto클래스를 생성하겠습니다. src/main/java/패키지명/web/dto/PostsSaveRequestDto1234567891011121314151617181920212223242526import lombok.Builder;import lombok.Getter;import lombok.NoArgsConstructor;@Getter@NoArgsConstructorpublic class PostsSaveRequestDto { private String title; private String content; private String author; @Builder public PostsSaveRequestDto(String title, String content, String author) { this.title = title; this.content = content; this.author = author; } public Posts toEntity() { return Posts.builder() .title(title) .content(content) .author(author) .build(); }} 여기서 Entity클래스와 거의 유사한 형태임에도 Dto클래스를 추가로 생성했습니다.하지만, 절대로 Entity 클래스를 Request/Response 클래스로 사용해서는 안됩니다. Entity클래스와 Dto클래스를 분리해서 사용해야 하는 이유&nbsp;Entity클래스는 데이터베이스와 맞닿은 핵심 클래스 입니다. Entity클래스를 기준으로 테이블이 생성되고, 스키마가 변경됩니다. 화면 변경은 아주 사소한 기능 변경인데, 이를 위해 테이블과 연결된 Entity클래스를 변경하는 것은 너무 큰 변경입니다. 수많은 서비스 클래스나 비즈니스 로직들이 Entity클래스를 기준으로 동작합니다. Entity클래스가 변경되면 여러 클래스에 영향을 끼치지만, Request와 Response용 Dto는 View를 위한 클래스라 정말 자주 변경이 필요합니다. &nbsp; View Layer와 DB Layer의 역할 분리를 철저하게 하는 게 좋습니다. 실제로 Controller에서 결과값으로 여러 테이블을 조인해서 줘야 할 경우가 빈번하므로 Entity클래스만으로 표현하기가 어려운 경우가 많습니다.&nbsp;그렇기 때문에 Entity클래스와 Controller에 쓸 Dto는 분리해서 사용해야 합니다. 테스트 코드로 검증하기src/test/java/패키지명/web/PostsApiControllerTest1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.junit.After;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.web.client.TestRestTemplate;import org.springframework.boot.web.server.LocalServerPort;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;import static org.assertj.core.api.Assertions.assertThat;@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class PostsApiControllerTest { @LocalServerPort private int port; @Autowired private TestRestTemplate restTemplate; @Autowired private PostsRepository postsRepository; @After public void tearDown() throws Exception{ postsRepository.deleteAll(); } @Test public void Posts_등록된다() throws Exception{ //given String title =&quot;title&quot;; String content = &quot;content&quot;; PostsSaveRequestDto requestDto = PostsSaveRequestDto.builder() .title(title) .content(content) .author(&quot;author&quot;) .build(); String url = &quot;http://localhost:&quot;+port+&quot;/api/v1/posts&quot;; //when ResponseEntity&lt;Long&gt; responseEntity = restTemplate.postForEntity(url, requestDto, Long.class); //then assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(responseEntity.getBody()).isGreaterThan(0L); List&lt;Posts&gt; all = postsRepository.findAll(); assertThat(all.get(0).getTitle()).isEqualTo(title); assertThat(all.get(0).getContent()).isEqualTo(content); }} &nbsp;Api Controller를 테스트하는데 HelloController와 달리 @WebMvcTest를 사용하지 않았습니다.@WebMvcTest의 경우 JPA기능이 작동하지 않기때문인데, Controller와 ControllerAdvice 등 외부 연동과 관련된 부분만 활성화되니 지금같이 JPA기능 까지 한번에 테스트할 때는 @SpringBootTest와 TestRestTemplate을 사용하면 됩니다. 등록 기능을 완성했으니 수정/조회 기능도 만들어봅시다. PostsApiController1234567891011121314151617@RequiredArgsConstructor@RestControllerpublic class PostsApiController {...중략 @PutMapping(&quot;/api/v1/posts/{id}&quot;) public Long update(@PathVariable Long id, @RequestBody PostsUpdateRequestDto requestDto){ return postsService.update(id, requestDto); } @GetMapping(&quot;/api/v1/posts/{id}&quot;) public PostsResponseDto findById (@PathVariable Long id){ return postsService.findById(id); }} src/main/java/패키지명/web/dto/PostsResponseDto1234567891011121314@Getterpublic class PostsResponseDto { private Long id; private String title; private String content; private String author; public PostsResponseDto(Posts entity) { this.id = entity.getId(); this.title = entity.getTitle(); this.content = entity.getContent(); this.author = entity.getAuthor(); }} PostsResponseDto는 Entity의 필드 중 일부만 사용하므로 생성자로 Entity를 받아 필드에 값을 넣습니다. 굳이 모든 필드를 가진 생성자가 필요하진 않으므로 Dto는 Entity를 받아 처리합니다. src/main/java/패키지명/web/dto/PostsUpdateRequestDtoResponseDto12345678910111213141516import lombok.Builder;import lombok.Getter;import lombok.NoArgsConstructor;@Getter@NoArgsConstructorpublic class PostsUpdateRequestDto { private String title; private String content; @Builder public PostsUpdateRequestDto(String title,String content){ this.title=title; this.content=content; }} src/main/java/패키지명/domain/posts/Posts12345678public class Posts { ...중략 public void update(String title, String content) { this.title = title; this.content = content; }} src/main/java/패키지명/service/posts/PostsService12345678910111213141516171819202122232425@RequiredArgsConstructor@Servicepublic class PostsService { ...중략 @Transactional public Long save(PostsSaveRequestDto requestDto){ return postsRepository.save(requestDto.toEntity()).getId(); } @Transactional public Long update(Long id, PostsUpdateRequestDto requestDto){ Posts posts = postsRepository.findById(id) .orElseThrow(()-&gt; new IllegalArgumentException(&quot;해당 게시글이 없습니다. id=&quot;+id)); posts.update(requestDto.getTitle(), requestDto.getContent()); return id; } public PostsResponseDto findById(Long id){ Posts entity = postsRepository.findById(id) .orElseThrow(()-&gt; new IllegalArgumentException(&quot;해당 게시글이 없습니다. id=&quot;+id)); return new PostsResponseDto(entity); }} &nbsp;여기서 신기한 것이 있습니다. update기능에서 데이터베이스에 쿼리를 날리는 부분이 없습니다.**이게 가능한 이유는 **JPA의 영속성 컨텍스트 때문입니다. &nbsp;영속성 컨텍스트란, 엔티티를 영구 저장하는 환경입니다. 일종의 논리적 개념이라고 보면 되며, JPA의 핵심 내용은 엔티티가 영속성 컨텍스트에 포함되어 있냐 아니냐로 갈립니다. &nbsp;JPA의 엔티티 매니저가 활성화된 상태로(Spring Data Jpa를 쓴다면 기본 옵션) 트랜젝션 안에서 데이터베이스에서 데이터를 가져오면 이 데이터는 영속성 컨텍스트가 유지된 상태입니다. &nbsp;이 상태에서 해당 데이터의 값을 변경하면 트랜잭션이 끝나는 시점에 해당 테이블에 변경분을 반영합니다. 즉, Entity객체의 값만 변경하면 별도로 Update쿼리를 날릴 필요가 없다는 것이죠. 이 개념을 더티 체킹이라고 합니다. 이제 실제로 이 코드가 정상적으로 Update쿼리를 수행하는지 테스트 코드로 확인해 봅시다.수정 기능의 테스트 코드는 등록 기능과 마찬가지로 PostApiControllerTest에 추가하겠습니다. src/test/java/패키지명/web/PostsApiControllerTest123456789101112131415161718192021222324252627282930313233343536373839@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class PostsApiControllerTest {...중략@Test public void Posts_수정된다() throws Exception { //given Posts savedPosts = postsRepository.save(Posts.builder() .title(&quot;titile&quot;) .content(&quot;content&quot;) .author(&quot;author&quot;) .build()); Long updateId = savedPosts.getId(); String expectedTitle=&quot;title2&quot;; String expectedContent=&quot;content2&quot;; PostsUpdateRequestDto requestDto = PostsUpdateRequestDto.builder() .title(expectedTitle) .content(expectedContent) .build(); String url =&quot;http://localhost:&quot;+port+&quot;/api/v1/posts/&quot;+updateId; HttpEntity&lt;PostsUpdateRequestDto&gt; requestEntity = new HttpEntity&lt;&gt;(requestDto); //when ResponseEntity&lt;Long&gt; responseEntity = restTemplate.exchange(url, HttpMethod.PUT, requestEntity, Long.class); //then assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(responseEntity.getBody()).isGreaterThan(0L); List&lt;Posts&gt; all = postsRepository.findAll(); assertThat(all.get(0).getTitle()).isEqualTo(expectedTitle); assertThat(all.get(0).getContent()).isEqualTo(expectedContent); }} 조회 기능은 실제로 톰캣을 실행해서 확인해 보겠습니다. 1.application.properties에 spring.h2.console.enabled=true 코드 추가 합니다. 2.추가한 뒤 Application클래스의 main메소드를 실행합니다. 3.웹 브라우저에서 http://localhost:8080/h2-console로 접속합니다. 4.JDBC URL: jdbc:h2:mem:testdb로 되있는지 확인한다. 만약 다르다면 수정해준다. 5.확인 후 아래 Connect버튼을 클릭한다. 그러면 H2를 관리할 수 있는 관리 페이지로 이동합니다.POSTS테이블이 정상적으로 노출되어야만 합니다. 간단하게 insert쿼리를 실행해보고 이를 API로 조회해 보겠습니다.**insert into posts (author, content, title) values(‘author’, ‘content’, ‘title’);**을 입력하고 Run을 클릭합니다.등록후 http://localhost:8080/api/v1/posts/1으로 이동하여 API조회 기능을 테스트해 봅니다. JPA Audtiting을 이용한 등록/수정 시간 자동화&nbsp; 보통 엔티티에는 해당 데이터의 생성시간과 수정시간을 포함합니다.언제 만들어졌는지, 언제 수정되었는지 등은 차후 유지보수에 있어서 중요한 정보입니다. 그렇기 때문에 DB에 삽입하기 전, 갱신 하기 전에 날짜 데이터를 등록/수정하는 코드가 여기저기 들어가게 됩니다. LocalData사용하기Java8부터 LocalDate와 LocalDateTime이 등장했습니다. 이는 Java의 기본 날짜 타입인 Date의 문제점을 고친 타입이라 Java9일 경우 무조건 써야 한다고 생각하면 됩니다. Java8 이전 Date/Calendar 클래스의 문제점 1.불변 객체가 아닙니다. 멀티스레드 환경에서 언제든 문제가 발생할 수 있습니다. 2.Calendar는 월(Month) 값 설계가 잘못되었습니다. 10월을 나타내는 Calendar.OCTOBER의 숫자 값은 ‘9’입니다. 당영히 ‘10’으로 생각했던 개발자들에게는 큰 혼란이 왔습니다. jodaTime이라는 오픈소스를 사용해서 문제점들을 피했었고, java8에선 LocalDate를 통해 해결했습니다. domain패키지에 BaseTimeEntity클래스를 생성합니다. 123456789101112131415161718192021import lombok.Getter;import org.springframework.data.annotation.CreatedDate;import org.springframework.data.annotation.LastModifiedDate;import org.springframework.data.jpa.domain.support.AuditingEntityListener;import javax.persistence.EntityListeners;import javax.persistence.MappedSuperclass;import java.time.LocalDate;import java.time.LocalDateTime;@Getter@MappedSuperclass@EntityListeners(AuditingEntityListener.class)public class BaseTimeEntity { @CreatedDate private LocalDateTime createdDate; @LastModifiedDate private LocalDateTime modifiedDate;} @MappedSuperclass JPA Entity 클래스들이 BaseTimeEntity을 상속할 경우 필드들(createdDate, modifiedDate)도 칼럼으로 인식하도록 합니다. @EntityListeners BaseTimeEntity 클래스에 Auditing 기능을 포함시킵니다. @CreatedDate Entity가 생성되어 저장될 때 시간이 자동 저장됩니다. @LastModifiedDate 조회한 Entity의 값을 변경할 때 시간이 자동으로 저장됩니다. 그리고 Posts클래스가 BaseTimeEntity를 상속받도록 변경합니다. 123public class Posts extends BaseTimeEntity {...증략} 마지막으로 JPA Auditing 어노테이션들을 모두 활성화할 수 있도록 Application클래스에 활성화 어노테이션 하나를 추가하겠습니다. 1234567@EnableJpaAuditing // JPA Auditing 활성화@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} JPA Auditing테스트 코드 작성PostsRepositoryTest클래스에 데스트 메소드를 하나 더 추가하겠습니다. 12345678910111213141516171819202122 @Test public void BaseTimeEntity_등록() { // given LocalDateTime now = LocalDateTime.of(2020,2,25,0,0,0); postsRepository.save(Posts.builder() .title(&quot;title&quot;) .content(&quot;content&quot;) .author(&quot;author&quot;) .build()); // when List&lt;Posts&gt; postsList = postsRepository.findAll(); // then Posts posts = postsList.get(0); System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; createDate=&quot;+posts.getCreatedDate()+&quot;, modifiedDate=&quot;+posts.getModifiedDate()); assertThat(posts.getCreatedDate()).isAfter(now); assertThat(posts.getModifiedDate()).isAfter(now); }}","link":"/2021/01/10/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%97%90%EC%84%9CJPA%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8B%A4%EB%A3%A8%EA%B8%B0/"},{"title":"4장. 머스테치로_화면_구성하기","text":"* 스프링 부트와 AWS로 혼자 구현하는 웹 서비스(프리렉, 이동욱 지음)책을 통해 공부한 내용을 정리한 글입니다. * 목록 서버 템플릿 엔진과 머스테치 소개 게시글 등록 화면 만들기 게시글 조회 화면 만들기 게시글 수정, 삭제 화면 만들기 서버 템플릿 엔진과 머스테치 소개먼저 템플릿 엔진이란 무엇인지 소개 드리겠습니다. 일반적으로 웹 개발에 있어 템플릿 엔진이란, 지정된 템플릿 양식과 데이터가 합쳐져 HTML문서를 출력하는 소프트웨어를 이야기 합니다.Spring 이나 서블릿 같은 경우는 JSP, Freemarker 등, React와 Vue같은 경우는 View파일들이 지정된 템플릿과 데이터를 이용하여 HTML을 생성하는 템플릿 엔진 입니다.다만, 조금의 차이가 있습니다. 전자는 서버 템플릿이라 불리며, 후자는 클라이언트 템플릿 엔진이라 불립니다. 자바스크립트에서 JSP나 Freemarker처럼 자바 코드를 사용할 순 없는가?&nbsp;여기서 중요한 것은 프론트엔드의 자바스크립트(NodeJs가 아닙니다.)가 작동하는 영역과 JSP 가 작동하는 영역이 다르다는 것 입니다. 그렇기 떄문에 JSP를 비롯한 서버 템플릿 엔진은 서버에서 구동이 됩니다. JSP는 명확하게는 서버 템플릿 엔진은 아닙니다만, View의 역활만 하도록 구성할 떄는 템플릿 엔진으로써 사용할 수 있습니다. 이 경우에는 Spirng + JSP로 사용한 경우로 보면 됩니다.&nbsp;서버 템플릿 엔진을 이용한 화면 생성은 서버에서 Java코드로 문자열을 만든 뒤 이 문자열을 HTML로 변환하여 브라우저로 전달합니다.이때의 자바스크립트 코드는 단순한 문자열일 뿐입니다. &nbsp;반면에 자바스크립트는 브라우저 위에서 작동합니다. 브라우저에서 작동될 때는 서버 템플릿 엔진의 손을 벗어나 제어할 수가 없습니다. 흔히 이야기하는 Vue.js나 React.js를 이용한 SPA(Single Page Application)는 브라우저에서 화면을 생성합니다. 즉, 서버에서 이미 코드가 벗어난 경우 입니다. &nbsp;자바스크립트 프레임워크의 화면 생성 방식을 서버에서 실행하면 가능합니다. 이는 V8 엔진 라이브러리들이 지원하기 떄문이며, 스프링 부트에서 사용할 수 있는 대표적인 기술로는 Nashorn, J2V8이 있습니다. 머스테치(Mustache)란수많은 언어를 지원하는 가장 심플한 템플릿 엔진입니다.루비, 자바스크립트, 파이썬, PHP, 자바, 펄, Go, ASP등 현존하는 대부분 언어를 지원하고 있습니다. 자바 진영 템플릿 엔진들의 단점, 머스테치의 장점JSP,Velocity 스프링 부트에서 권장하지 않는 템플릿 엔진입니다. Freemarker 템플릿 엔진으로는 너무 과하게 많은 기능을 지원합니다. 높은 자유도로 인해 숙련도가 낮을수록 Freemarker안에 비즈니스 로직이 추가될 확률이 높습니다. Thymeleaf 스프링 진영에서 적극적으로 밀고 있지만 문법이 어렵습니다. HTML태그에 속성으로 템플릿 기능을 사용하는 방식이 기존 개발자들께 높은 허들로 느껴지는 경우가 많습니다. Vue.js를 사용해 본 경험이 있어 태그 속성 방식이 익숙한 분이라면 Thymeleaf를 선택해도 됩니다. Mustache 문법이 다른 템플릿 엔진보다 심플합니다. 로직 코드를 사용할 수 없어 View의 역할과 서버의 역할이 명확하게 분리됩니다. Mustache.js와 Mustache.java 2가지가 다 있어, 하나의 문법으로 클라이언트/서버 템플릿을 모두 사용 가능합니다. 머스테치 플러그인 설치Action(Ctrl+Shift+A) → plugins 검색 → Marketplace 탭으로 이동 → Mustache검색 후 설치 → 인텔리제이 재시작 재시작 후 build.gradle에 머스테치 스타터 의존성을 등록해줍니다. build.gradle1234dependencies { ... compile('org.springframework.boot:spring-boot-starter-mustache')} 기본 페이지 만들기머스테치의 파일 위치는 기본적으로 src/main/resources/templates입니다. 이 위치에 머스테치 파일을 두면 스프링 부트에서 자동으로 로딩합니다. 첫페이지를 담당할 index.mustache를 src/main/resources/templates에 생성합니다.index.mustache의 코드는 다음과 같이 작성해 줍니다. index.mustache12345678910&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;스프링부트 웹서비스&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;스프링 부트로 시작하는 웹 서비스&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 간단하게 h1크기로 “스프링 부트로 시작하는 웹 서비스”를 출력하는 페이지 입니다. 이 머스테치에 URL을 매핑합니다. URL매핑은 당영하게 Controller에서 진행합니다.web패키지 안에 indexController를 생성합니다. src/main/java/패키지명/web/indexController123456789101112import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class IndexController { @GetMapping(&quot;/&quot;) public String index() { return &quot;index&quot;; }} 머스테치 스타터 덕분에 컨드롤러에서 문자열을 반환할 때 앞의 경로와 뒤의 파일 확장자는 자동으로 지정됩니다.앞의 경로는 src/main/resources/templates로, 뒤의 파일 확장자는 .mustache가 붙는 것입니다.즉, 위 코드에선 “index”을 반환하므로, src/main/resources/templates/index.mustache로 전환되어 View Resolver가 처리하게 됩니다. ViewResolver는 URL요청의 결과를 전달할 타입과 값을 지정하는 관리자 격으로 볼 수 있습니다.코드가 완성되었으니 테스트 코드로 검증해 보겠습니다. test패키지에 IndexControllerTest클래스를 생성합니다. src/test/java/패키지명/web/IndexControllerTest1234567891011121314151617181920212223242526import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.web.client.TestRestTemplate;import org.springframework.test.context.junit4.SpringRunner;import static org.assertj.core.api.Assertions.assertThat;import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = RANDOM_PORT)public class IndexControllerTest { @Autowired private TestRestTemplate restTemplate; @Test public void 메인페이지_로딩() { // when String body = this.restTemplate.getForObject(&quot;/&quot;, String.class); // then assertThat(body).contains(&quot;스프링 부트로 시작하는 웹 서비스&quot;); }} 이번 테스트는 실제로 URL호출시 페이지의 내용이 제대로 호출되는지에 대한 테스트 입니다.HTML도 결국은 규칙이 있는 문자열입니다. TestRestTemplate를 통해 “/“를 호출했을 때 Index.mustache에 포홤된 코드들이 있는지 확인하면 됩니다. 전체 코드를 전부다 검증할 필요는 없으니 “스프링 부트로 시작하는 웹 서비스”문자열이 포함되어 있는지만 비교합니다. 게시글 등록 화면 만들기이전에 만들었던 PostsApiController에 구현한 API로 게시글 등록 화면을 개발합니다.오프소스인 부트 스트랩을 이용하여 화면을 구성합니다. 부트스트랩, 제이쿼리 등 프론트엔드 라이브러리를 사용할 수 있는 방법은 크게 2가지가 있습니다. 1.외부 CDN사용 2.직접 라이브러리를 받아서 사용 여기서는 외부 CDN을 사용합니다. 실제 서비스에서는 이 방법을 잘 사용하지 않습니다. 결국은 외부 서비스에 우리 서비스가 의존하게 돼버려서, CDN을 서비스하는 곳에 문제가 생기면 덩달아 같이 문제가 생기기 떄문입니다.2개의 라이브러리 부트 스트랩과 제이쿼리를 index.mustache에 추가해야 합니다. 하지만, 여기서는 바로 추가하지 않고 레이아웃 방식(공통 영역을 별도의 파일로 분리하여 필요한 곳에서 가져다 쓰는 방식)으로 추가해 보겠습니다. 이번에 추가할 라이브러리들인 부트스트랩과 제이쿼리는 머스테치 화면 어디서나 필요합니다. 그렇기 때문에 레이아웃 파일들을 만들어 라이브러리를 추가 편합니다. src/main/resources/template 디렉토리에 layout디렉토리를 추가로 생성해 줍니다. 그리고 header.mustache,footer.mustache파일을 생성합니다. header.mustache123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;스프링부트 웹서비스&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; footer.mustache12345&lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 코드를 살펴보면 css, js의 위치가 서로 다릅니다. 페이지 로딩속도를 높이기 위해 css는 header에, js는 footer에 두었습니다. HTML은 위에서부터 코드가 실행되기 때문에 head가 다 실행되고서야 body가 실행됩니다. head가 다 불러지지 않으면 사용자는 백지 화면만 보이게 됩니다. js의 용량이 커지면 body부분의 실행이 늦어지기 때문에 js는 body하단에 두어 화면이 그려진뒤 호출하는게 좋습니다. 반대로, css는 화면을 그리는 역활을 하기 때문에 head에서 불러오는 것이 좋습니다. 그렇지 않으면 사용자는 css가 적용되지 않은 깨진 화면을 보게 됩니다. 추가로 bootstrap.js의 경우 제이쿼리가 꼭 있어야만 하기 때문에 부트스트랩보다 먼저 호출되도록 코드를 작성했습니다. 라이브러리를 비롯하여 기타 HTML태그들이 모두 레이아웃에 추가 되니 index.mustache에는 필요한 코드만 남게 됩니다.index.mustache의 코드를 다음과 같이 변경합니다. index.mustache123{{&gt;layout/header}} &lt;h1&gt;스프링 부트로 시작하는 웹 서비스&lt;/h1&gt;{{&gt;layout/footer}} {{&gt;header/mustache}} {{&gt;}}는 현재 머스테치 파일(index.mustache)을 기준으로 다른 파일을 가져옵니다. 게시글 등록 1.게시글 등록 버튼 만들기 2.등록 페이지 URL 호출 3.게시글 등록 페이지 만들기 4.게시글 등록 버튼 기능 추가 1.게시글 등록 버튼 만들기index.mustache123456789101112{{&gt;layout/header}}&lt;h1&gt;스프링부트로 시작하는 웹 서비스 Ver.2&lt;/h1&gt;&lt;div class=&quot;col-md-12&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;a href=&quot;/posts/save&quot; role=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;글 등록&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;{{&gt;layout/footer}} 2.등록 페이지 URL 호출이동할 페이지 주소는 /posts/save입니다. IndexController123456789@RequiredArgsConstructor@Controllerpublic class IndexController {...중략@GetMapping(&quot;/posts/save&quot;) public String postsSave() { return &quot;posts-save&quot;; }} 3.게시글 등록 페이지 만들기index.mustache와 같은 위치에 posts-save.mustache 파일 생성합니다. posts-save.mustache12345678910111213141516171819202122232425{{&gt;layout/header}}&lt;h1&gt;게시글 등록&lt;/h1&gt;&lt;div class=&quot;col-md-12&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;제목&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;title&quot; placeholder=&quot;제목을 입력하세요&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;author&quot;&gt;사용자&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;author&quot; placeholder=&quot;작성자를 입력하세요&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;content&quot;&gt;내용&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;content&quot; placeholder=&quot;내용을 입력하세요&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;a href=&quot;/&quot; role=&quot;button&quot; class=&quot;btn btn-secondary&quot;&gt;취소&lt;/a&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;btn-save&quot;&gt;등록&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;{{&gt;layout/footer}} 4.게시글 등록 버튼에 기능 추가아직은 게시글 등록 화면에 등록 버튼은 아무런 기능이 없습니다. API를 호출하는 JS가 전혀 없기 때문입니다.src/main/resourse에 static/js/app디렉토리를 생성하고 index.js를 생성합니다. index.js1234567891011121314151617181920212223242526272829var main = { init : function(){ var _this = this; $('#btn-save').on('click', function() {_this.save(); }); }, save : function(){ var data ={ title: $('#title').val(), author: $('#author').val(), content: $('#content').val() }; $.ajax({ type: 'POST', url: '/api/v1/posts', dataType: 'json', contentType: 'application/json; charset=UTF-8', data: JSON.stringify(data) }).done(function(){ alert('글이 등록되었습니다.'); window.location.href='/'; }).fail(function(){ alert(JSON.stringify(error)); }); } };main.init(); window.location.href=’/‘ 글 등록이 성공하면 메인 페이지로(/)로 이동합니다. index.js의 첫 문장에 var main = {…}라는 코드를 선언했습니다.굳이 main이라는 변수의 속성으로 function을 추가한 이유는 뭘까요?예를 들어 설명 하겠습니다. 만약 index.js가 다음과 같이 function을 작성한 상황이라고 가정하겠습니다. 12345678910var init = function() { ... };var save = function() { ...}init(); index.mustache에서 a.js가 추가되어 a.js도 a.js만의 init과 save function이 있다면 어떻게 될까요?브라우저의 스코프는 공용 공간으로 쓰이기 때문에 나중에 로딩된 js의 init, save가 먼저 로딩된 js의 function을 덮어쓰게 됩니다. 여러 사람이 참여하는 프로젝트에서는 중복된 함수 이름은 자주 발생할 수 있습니다. 모든 function이름을 확인하면서 만들 수는 없습니다. 그러다 보니 이런 문제를 피하려고 index.js만의 유효범위를 만들어 사용합니다. 방법은 var main이란 객체를 만들어 해당 객체에서 필요한 모든 function을 선언하는 것입니다. 이렇게 하면 main 객체 안에서만 function이 유효하기 때문에 다른 JS와 겹칠 위험이 사라집니다. 생성된 index.js를 머스테치 파일이 쓸 수 있게 footer.mustache에 추가 하겠습니다. footer.mustache1234567&lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;!--index.js 추가--&gt;&lt;script src=&quot;/js/app/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ndex.js 호출 코드를 보면 **절대 경로(/)**로 시작합니다.스프링 부트는 기본적으로 src/main/resources/static에 위치한 자바스크립트, CSS, 이미지 등 정적 파일들을 URL에서 /로 설정됩니다. 또한, 다음과 같이 파일이 위치하면 위치에 맞게 호출이 가능합니다. src/main/resources/static/js/… (http://도메인/js/...) src/main/resources/static/css/… (http://도메인/css/...) src/main/resources/static/image/… (http://도메인/image/...) 게시글 조회 화면 만들기 1.index.mustache 수정 2.Controller, Service, Repository 수정 1.index.mustache 수정index.mustache12345678910111213141516171819202122232425262728293031323334{{&gt;layout/header}}&lt;h1&gt;스프링부트로 시작하는 웹 서비스 Ver.2&lt;/h1&gt;&lt;div class=&quot;col-md-12&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;a href=&quot;/posts/save&quot; role=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;글 등록&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;!-- 목록 출력 영역 --&gt; &lt;table class=&quot;table table-horizontal table-bordered&quot;&gt; &lt;thead class=&quot;thead-strong&quot;&gt; &lt;tr&gt; &lt;th&gt;게시글번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;최정수정일&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id =&quot;tbody&quot;&gt; {{#posts}} &lt;tr&gt; &lt;td&gt;{{id}}&lt;/td&gt; &lt;td&gt;{{title}}&lt;/a&gt;&lt;/td&gt; &lt;td&gt;{{author}}&lt;/td&gt; &lt;td&gt;{{modifiedDate}}&lt;/td&gt; &lt;/tr&gt; {{/posts}} &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;{{&gt;layout/footer}} {{posts}} posts 라는 List를 순회합니다. Java의 for문과 동일하게 생각하면 됩니다. {{id}} 등의 {{변수명}} List에서 뽑아낸 객체의 필드를 사용합니다. 2.Controller, Service, Repository 수정PostsRepository12345678910import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import java.util.List;public interface PostsRepository extends JpaRepository&lt;Posts, Long&gt; { @Query(&quot;SELECT p FROM Posts p ORDER BY p.id DESC&quot;) List&lt;Posts&gt; findAllDesc();} SpringDataJpa에서 제공하지 않는 메소드는 위처럼 쿼리로 작성해도 가능합니다. 참고 규모가 있는 프로젝트에서의 데이터 조회는 FK의 조인, 복잡한 조건 등으로 인해 이런 Entity 클래스만으로 처리하기 어려워 조회용 프레임워크를 추가로 사용합니다. 대표적 예로 querydsl, jooq, MyBatis 등이 있습니다. 조회는 위 3가지 프레임워크 중 하나를 통해 조회하고, 등록/수정/삭제 등은 SpringDataJpa를 사용합니다. Querydsl 추천하는 이유 1.타입 안정성이 보장됩니다. 단순한 문자열로 쿼리를 생성하는 것이 아니라, 메소드를 기반으로 쿼리를 생성하기 때문에 오타나 존재하지 않는 컬럼명을 명시할 경우 IDE에서 자동으로 검출됩니다. 이 장점은 Jooq에서도 지원하는 장점이지만, MyBatis에서는 지원하지 않습니다. 2.국내 많은 회사에서 사용 중입니다. 3.레퍼런스가 많습니다. 앞 2번의 장점에서 이어지는 것인데, 많은 회사와 개발자들이 사용하다보니 그만큼 국내 자료가 많습니다. 어떤 문제가 발생했을 떄 여러 커뮤니티에 질문하고 그에 대한 답변을 들을 수 있다는 것은 큰 장점입니다. PostsService12345678910111213141516import java.util.List;import java.util.stream.Collectors;@RequiredArgsConstructor@Servicepublic class PostsService { private final PostsRepository postsRepository; ...중략 @Transactional(readOnly = true) public List&lt;PostsListResponseDto&gt; findAllDesc() { return postsRepository.findAllDesc().stream() .map(PostsListResponseDto::new) .collect(Collectors.toList()); }} @Transactional에 **(readOnly = true)**을 주면 트랜잭션 범위는 유지하되, 조회 기능만 남겨두어 조회 속도가 개선 되기 때문에 등록, 수정, 삭제 기능이 전혀 없는 서비스 메소드에서 사용하는 것을 추천합니다. .map(PostsListResponseDto::new)[람다식]은 **.map(posts -&gt; new PostsListResponseDto(posts))**와 같습니다.postsRepository 결과로 넘어온 Posts의 Stream을 map을 통해 PostsListResponseDto 변환 -&gt; List로 반환하는 메소드 입니다. PostsListResponseDto1234567891011121314151617181920import com.fasterxml.jackson.annotation.JsonFormat;import com.jojoldu.book.springboot.domain.posts.Posts;import lombok.Getter;import java.time.LocalDateTime;@Getterpublic class PostsListResponseDto { private Long id; private String title; private String author; private LocalDateTime modifiedDate; public PostsListResponseDto(Posts entity){ this.id=entity.getId(); this.title=entity.getTitle(); this.author= entity.getAuthor(); this.modifiedDate=entity.getModifieDate(); }} indexController123456789101112131415import org.springframework.ui.Model;@RequiredArgsConstructor@Controllerpublic class IndexController { private final PostsService postsService; @GetMapping(&quot;/&quot;) public String index(Model model) { model.addAttribute(&quot;posts&quot;, postsService.findAllDesc()); return &quot;index&quot;; }} Model 서버 템플릿 엔진에서 사용할 수 있는 객체를 저장할 수 있습니다. 여기서는 postsService.findAllDesc()로 가져온 결과를 posts로 index.mustache에 전달합니다. application의 main메소드를 실행시킨다음 http://localhost:8080/으로 접속합니다.접속한 뒤 등록 화면을 이용해 하나의 데이터를 등록해 봅니다. 그럼 다음과 같이 목록 기능이 정상적으로 작동하는 것을 확인할 수 있습니다. 게시글 수정, 삭제 화면 만들기게시글 API는 예전에 이미 만들어 두었습니다. 123456789public class PostsApiController{...@PutMapping(&quot;/api/v1/posts/{id}&quot;) public Long update(@PathVariable Long id, @RequestBody PostsUpdateRequestDto requestDto){ return postsService.update(id, requestDto); } ...} 해당 API로 화면을 개발해 보겠습니다. 게시글 수정src/main/resources/templates/posts-update.mustache123456789101112131415161718192021222324252627282930{{&gt;layout/header}}&lt;h1&gt;게시글 수정&lt;/h1&gt;&lt;div class=&quot;col-md-12&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;id&quot;&gt;글 번호&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;id&quot; value=&quot;{{post.id}}&quot; readonly&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;제목&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;title&quot; value=&quot;{{post.title}}&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;author&quot;&gt; 작성자&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;author&quot; value=&quot;{{post.author}}&quot; readonly&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;content&quot;&gt; 내용&lt;/label&gt; &lt;textarea class=&quot;content&quot; id=&quot;content&quot;&gt;{{post.content}}&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;a href=&quot;/&quot; role=&quot;button&quot; class=&quot;btn btn-secondary&quot;&gt;취소&lt;/a&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;btn-update&quot;&gt;수정 완료&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;{{&gt;layout/footer}} {{posts.id}} 머스테치는 객체의 필드 접근 시 점(Dot)으로 구분합니다. 즉, Post클래스의 id에 대한 접근은 post.id로 사용할 수 있습니다. readonly Input태그에 읽기 기능만 허용하는 속성입니다. id와 author는 수정할 수 없도록 읽기만 허용하도록 추가합니다. btn-update버튼을 클릭하면 update기능을 호출할수 있게 index.js파일에 update function을 추가하겠습니다. src/main/resources/static.js.app/index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var main = { init : function(){ var _this = this; $('#btn-save').on('click', function() {_this.save(); }); $('#btn-update').on('click', function() {_this.update(); }); $('#btn-delete').on('click', function() {_this.delete(); }); }, save : function(){ var data ={ title: $('#title').val(), author: $('#author').val(), content: $('#content').val() }; $.ajax({ type: 'POST', url: '/api/v1/posts', dataType: 'json', contentType: 'application/json; charset=UTF-8', data: JSON.stringify(data) }).done(function(){ alert('글이 등록되었습니다.'); window.location.href='/'; }).fail(function(){ alert(JSON.stringify(error)); }); }, update : function(){ var data = { title: $('#title').val(), content: $('#content').val() }; var id = $('#id').val(); $.ajax({ type: 'PUT', url:'/api/v1/posts/'+id, dataType: 'json', contentType: 'application/json; charset=utf-8', data: JSON.stringify(data) }).done(function(){ alert('글이수정되었습니다.'); window.location.href = '/'; }).fail(function(error){ alert(JSON.stringify(error)); }); }};main.init(); $(‘#btn-update’).on(‘click’) btn-update란 id를 가진 HTML 엘리먼트에 click 이벤트가발생할 때 update function을 실행하도록 이벤트를 등록합니다. update : function () 신규로 추가될 update function 입니다. type: ‘PUT’ 여러 HTTP Method 중 PUT 메소드를 선택합니다. PostApiController에 있는 API에서 이미 @PutMapping으로 선언했기 떄문에 PUT을 사용해야 합니다. 참고로 이는 REST 규약에 맞게 설정된 것입니다. REST에서 CRUD는 다음과 같이 HTTP Method에 매핑 됩니다. 생성(Create) - POST 읽기(Read) - GET 수정(Update) - PUT 삭제(Delete) - DELETE url: ‘/api/v1/posts/‘+id 어느 게시글을 수정할지 URL Path로 구분하기 위해 Path에 id를 추가합니다. 화면쪽 작업이 다 끝났으니 수정 화면을 연결할 Controller 코드를 작업하겠습니다. indexController1234567891011public class IndexController{...중략@GetMapping(&quot;/posts/update/{id}&quot;) public String postsUpdate(@PathVariable Long id, Model model){ PostsResponseDto dto = postsService.findById(id); model.addAttribute(&quot;post&quot;, dto); return &quot;posts-update&quot;; }} 작업이 끝났으니 실제로 잘 작동하는지 확인해 보겠습니다. 수정 링크 표시해당 링크를 누르면 수정 페이지로 이동합니다. 제목과 내용 수정글 번호와 작성자가 읽기전용 상태 인것을 확인한 뒤, 제목과 내용을 수정해 봅니다. 게시글 삭제수정 기능이 정상적으로 구현되었으니, 삭제 기능도 구현해 봅니다.먼저 삭제 버튼을 화면에 추가하겠습니다. src/main/resources/templates/posts-update.mustache123456789101112131415{{&gt;layout/header}}&lt;h1&gt;게시글 수정&lt;/h1&gt;&lt;div class=&quot;col-md-12&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; ... &lt;a href=&quot;/&quot; role=&quot;button&quot; class=&quot;btn btn-secondary&quot;&gt;취소&lt;/a&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;btn-update&quot;&gt;수정 완료&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot; id=&quot;btn-delete&quot;&gt;삭제&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;{{&gt;layout/footer}} btn-delete 삭제 버튼을 수정 완료 버튼 옆에 추가합니다. 해당 버튼 클릭 시 JS에서 이벤트를 수신할 예정입니다. 삭제 이벤트를 진행할 JS코드도 추가합니다. src/main/resources/static.js.app/index.js123456789101112131415161718192021222324252627var main = { init : function(){ var _this = this; ...중략 $('#btn-delete').on('click', function() {_this.delete(); }); }, ...중략 delete : function () { var id = $('#id').val(); $.ajax({ type: 'DELETE', url: '/api/v1/posts/'+id, dataType: 'json', contentType: 'application/json; charset=utf-8' }).done(function() { alert('글이 삭제되었습니다.'); window.location.href='/'; }).fail(function(error){ alert(JSON.stringify(error)); }); }};main.init(); 삭제 API을 만듭니다. 1234567891011...public class PostsService{ ...중략 @Transactional public void delete (Long id){ Posts posts = postsRepository.findById(id) .orElseThrow(() -&gt; new IllegalArgumentException(&quot;해당 게시글이 없습니다. id=&quot;+id)); postsRepository.delete(posts); } ...} postsRepository.delete(posts) JpaRepository에서 이미 delete 메소드를 지원하고 있으니 이를 활용합니다. 엔티티를 파라미터로 삭제할 수도 있고, deletById 메소드를 이용하면 id로 삭제할 수도 있습니다. 존재하는 Posts인지 확인을 위해 엔티티 조회 후 그대로 삭제합니다. 서비스엣서 만든 delete메소드를 컨트롤러가 사용하도록 코드를 추가합니다. 123456789101112...public class PostsApiController { ... @DeleteMapping(&quot;/api/v1/posts/{id}&quot;) public Long delete(@PathVariable Long id) { postsService.delete(id); return id; } ...} 컨트롤러까지 생성되었으니 한번 테스트를 해봅니다.게시글의 수정 화면에서 삭제 버튼을 클릭합니다. 삭제후 자동으로 메인 페이지로 이동됩니다.기존 게시글이 삭제되었는지 확인합니다.","link":"/2021/01/12/%EB%A8%B8%EC%8A%A4%ED%85%8C%EC%B9%98%EB%A1%9C-%ED%99%94%EB%A9%B4-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0/"},{"title":"5장. 스프링_시큐리티와_OAuth2.0","text":"* 스프링 부트와 AWS로 혼자 구현하는 웹 서비스(프리렉, 이동욱 지음)책을 통해 공부한 내용을 정리한 글입니다. * 목록 스프링 시큐리티와 스프링 시큐리티 OAuth2 클라이언트 구글 서비스 등록 및 구글 로그인 연동 어노테이션 기반으로 개선하기 세션 저장소로 데이터베이스 사용하기 네이버 로그인 기존 테스트에 시큐리티 적용하기 1. 스프링 시큐리티와 스프링 시큐리티 OAuth2 클라이언트스프링 시큐리티는 막강한 인증(Authentication)과 인가(Authorization)기능을 가진 프레임워크입니다. 사실상 스프링 기반의 애플리케이션에서는 보안을 위한 표준이라고 보면 됩니다. 인터셉터, 필터 기반의 보안 기능을 구현하는 것보다 스프링 시큐리티를 통해 구현하는 것을 적극적으로 권장하고 있습니다. 왜 많은 서비스에서 소셜 로그인을 사용할까요? 만약 로그인을 직접 구현한다하면 다음을 전부 구현해야 합니다. 로그인 시 보안 비밀번호 찾기 비밀번호 변경 회원정보 변경 회원가입 시 이메일 혹은 전화번호 인증 OAuth 로그인 구현 시 앞선 목록의 것들을 모두 구글, 페이스북, 네이버 등에 맡기면 되니 서비스 개발에 집중 할 수 있기 때문입니다. 스프링 부트 1.5 VS 스프링 부트 2.0스프링 부트 1.5에서의 OAuth2 연동방법이 2.0에서는 크게 변경되었습니다. 하지만, 인터넷 자료들을 보면 설정 방법에 크게 차이가 없는 경우를 자주 봅니다. 이는 spring-security-oauth2-autoconfigure라이브러리 덕분입니다. 이를 사용할 경우 스프링 부트 2에서도 1.5에서 쓰던 설정을 그대로 사용할 수 있습니다. 스프링 부트 2에 관련한 인터넷 자료를 찾고 싶을 때 다음 2가지 를 확인하면 됩니다. spring-security-oauth2-autoconfigure 라이브러리를 사용했는가? application.properties 혹은 application.yml 정보의 차이 스프링 부트 1.5 방식에서는 url 주소를 모두 명시해야 하지만, 2.0 방식에서는 client 인정 정보만 입력 하면 됩니다. 1.5버전에서 직접 입력했던 값들은 2.0버전으로 오면서 모두 enum으로 대체 되었습니다. CommonOAuth2Provider 라는 enum이 새롭게 추가되어 구글, 깃허브, 페이스북, 옥타(Okta)의 기본 설정값은 모두 여기서 제공합니다. 2. 구글 서비스 등록 및 구글 로그인 연동 구글 서비스 등록먼저 구글 서비스에 신규 서비스를 생성합니다. 여기서 발급된 인증 정보(clientId와 clientSecret)를 통해서 로그인 기능과 소셜 서비스 기능을 사용할 수 있느니 무조건 발급받고 시작합니다. 구글 클라우드 플랫폼으로 접속 상단에 프로젝트 선택 → 새 프로젝트 원하는 프로젝트 이름 지정 왼쪽 메뉴 탭 → API 및 서비스 사용자 인증 정보 → 사용자 인증 정보 만들기 선택 → OAuth 클라이언트 ID → 동의 화면 구성 어플 이름 지정, 지원 이메일, Google Api 범위(email, profile, openid) → 저장 OAuth 클라이언트 ID 만들기 화면 → 어플리케이션 유형 → 웹 어플리케이션 승인된 리디렉션 URI → http://localhost:8080/login/oauth2/code/google 입력 후 생성 서비스에서 파라미터로 인증 정보를 주었을 때 인증이 성공하면 구글에서 리다이렉트할 URL입니다. 스프링 부트 2 버전의 시큐리티에서는 기본적으로 {도메인}/login/oauth2/code/{소셜서비스코드}로 리다이렉트 URL을 지원하고 있습니다. 현재는 개발 단계이므로 http://localhost:8080/login/oauth2/code/google로만 등록합니다. AWS 서버에 배포하게 되면 localhost 외에 추가로 주소를 추가해야하며, 이건 이후 단계에서 진행합니다. 클라이언트 ID, 클라이언트 보안 비밀번호 생성 확인 구글 서비스 등록이 끝났다면 src/main/resources/ 디렉토리에 application-oauth.properties 파일을 생성 합니다.해당 파일에 클라이언트ID와 클라이언트 보안 비밀 코드를 다음과 같이 등록합니다. application-oauth.properties123spring.security.oauth2.client.registration.google.client-id=클라이언트IDspring.security.oauth2.client.registration.google.client-secret=클라이언트 보안 비밀spring.security.oauth2.client.registration.google.scope=profile,email scope=profile,email 많은 예제에서는 이 scope를 별도로 등록하지 않고 있습니다. 기본값이 openid, profile, email이기 때문입니다. 강제로 profile, email를 등록한 이유는 openid라는 scope가 있으면 Open Id Provider로 인식하기 때문입니다. 이렇게 되면 OpenId Provider인 서비스(구글)와 그렇지 않은 서비스(네이버/카카오 등)로 나눠서 각각 OAuth2Service를 만들어야 합니다. 하나의 OAuth2Service로 사용하기 위해 일부러 openid scope를 빼고 등록합니다. 스프링 부트에서 properties의 이름을 application-xxx.properties로 xxx라는 이름의 profile이 생성되어 이를 통해 관리할 수 있습니다.즉, profile=xxx라는 식으로 호출하면 해당 properties의 설정들을 가져올 수 있습니다.application.properties에서 application-oauth.properties를 포함하도록 구성합니다.application.properties에 다음 코드를 추가합니다. application.properties1spring.profiles.include=oauth clientID와 clientSecret은 외부에 노출될 경우 언제든 개인정보를 가져갈 수 있는 중요한 정보들입니다. 깃허브에 application-oauth.properties파일이 올라가는 것을 방지하기 위해 .gitignore에 코드를 추가해 줍니다. gitignore1application-oauth.properties 구글 로그인 연동하기User 관련 Entity 1.User 클래스 2.Role Enum 클래스 3.UserRepository 클래스 스프링 시큐리티 설정 1.SecurityConfig 클래스 2.CustomOAuth2UserService 클래스 3.OAuthAttributes 클래스 4.SessionUser 클래스 User 관련 Entity 1.User 클래스사용자 정보를 담당할 도메인입니다.domain패키지 아래에 user 패키지를 생성합니다.user패키지에 User클래스를 생성합니다. src/main/java/패키지명/domain/user/User1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import 패키지명.domain.BaseTimeEntity;import lombok.Builder;import lombok.Getter;import lombok.NoArgsConstructor;import javax.persistence.*;@Getter@NoArgsConstructor@Entitypublic class User extends BaseTimeEntity { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String name; @Column(nullable = false) private String email; @Column private String picture; @Enumerated(EnumType.STRING) @Column(nullable = false) private Role role; @Builder public User(String name, String email, String picture, Role role) { this.name = name; this.email = email; this.picture = picture; this.role = role; } public User update(String name, String picture) { this.name = name; this.picture = picture; return this; } public String getRoleKey(){ return this.role.getKey(); }} **@Enumerated(EnumType.STRING) ** JPA로 데이터베이스로 저장할 때 Enum 값을 어떤 형태로 저장할지를 결정합니다. 기본적으로는 int로 된 숫자가 저장됩니다. 숫자로 저장되면 데이터베이스로 확인할 때 그 값이 무슨 코드를 의미하는지 알 수가없습니다. 그래서 문자열(EnumType.STRING)로 저장될 수 있도록 선언합니다. 2.Role Enum 클래스각 사용자의 권한을 관리를 담당할 Enum클래스입니다.user패키지에 Role이라는 Enum클래스를 생성합니다. src/main/java/패키지명/domain/user/Role12345678910111213import lombok.Getter;import lombok.RequiredArgsConstructor;@Getter@RequiredArgsConstructorpublic enum Role { GUEST(&quot;ROLE_GUEST&quot;, &quot;손님&quot;), USER(&quot;ROLE_USER&quot;, &quot;일반 사용자&quot;); private final String key; private final String title;} 스프링 시큐리티에서는 권한 코드에 항상 ROLE_ 이 앞에 있어야만 합니다.그래서 코드별 키 값을 ROLE_GUEST, ROLE_USER 등으로 지정합니다. 3.UserRepository 클래스User의 CRUD를 책임질 interface클래스입니다.user패키지에 UserRepository이라는 interface클래스를 생성합니다. src/main/java/패키지명/domain/user/UserRepository12345678package com.doop.book.springboot.domain.user;import org.springframework.data.jpa.repository.JpaRepository;import java.util.Optional;public interface UserRepository extends JpaRepository&lt;User, Long&gt; { Optional&lt;User&gt; findByEmail(String email);} findByEmail 소셜 로그인으로 반환되는 값 중 email을 통해 이미 생성된 사용자인지 처음 가입하는 사용자인지 판단하기 위한 메소드입니다. 스프링 시큐리티 설정 build.gradle에 스프링 시큐리티 관련 의존성을 하나를 추가합니다. build.gradle1compile('org.springframework.boot:spring-boot-starter-oauth2-client') org.springframework.boot:spring-boot-starter-oauth2-client 소셜 로그인 등 클라이언트 입장에서 소셜 기능 구현 시 필요한 의존성입니다. spring-boot-starter-oauth2-clientdhk spring-boot-starter-oauth2-jose를 기본으로 관리해줍니다. java디렉토리 아래에 Config.auth패키지를 생성합니다. 앞으로 시큐리티 관련 클래스는 모두 이곳에 담는다고 생각하시면 됩니다. 1.SecurityConfig 클래스OAuth라이브러리를 이용한 소셜 로그인 설정 코드를 작성합니다. src/main/java/패키지명/config/auth/SecurityConfig1234567891011121314151617181920212223242526272829import lombok.RequiredArgsConstructor;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@RequiredArgsConstructor@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter { private final CustomOAuth2UserService customOAuth2UserService; @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable().headers().frameOptions().disable() .and() .authorizeRequests() .antMatchers(&quot;/&quot;,&quot;/css/**&quot;,&quot;/images/**&quot;,&quot;/js/**&quot;,&quot;/h2-console/**&quot;).permitAll() .antMatchers(&quot;/api/v1/**&quot;).hasRole(Role.USER.name()) .anyRequest().authenticated() .and() .logout() .logoutSuccessUrl(&quot;/&quot;) .and() .oauth2Login() .userInfoEndpoint() .userService(customOAuth2UserService); }} @EnableWebSecurity Spring Security 설정들을 활성화시켜 줍니다. csrf().disable().headers().frameOptions().disable() h2-console 화면을 사용하기 위해 해당 옵션들을 disable 합니다 authorizeRequests URL별 권한 관리를 설정하는 옵션의 시작점입니다. authorizeRequests가 선업되어야만 antMatchers 옵션을 사용할 수 있습니다. antMatchers 권한 관리 대상을 지정하는 옵션입니다. URL, HTTP 메소드별로 관리가 가능합니다. ”/” 등 지정된 URL 들은 permitAll() 옵션을 통해 전체 열람 권한을 주었습니다. “/api/v1/**” 주소를 가진 API는 USER 권한을 가진 사람만 가능하도록 했습니다. ** anyRequest** 설정된 값들 이외 나머지 URL들을 나타냅니다. 여기서는 authenticated()을 추가하여 나머지 URL들은 모두 인증된 사용자들에게만 허용하게 합니다. 인증된 사용자 즉, 로그인한 사용자들을 이야기합니다. gout().logoutSuccessUrl(“/“) 로그아웃 기능에 대한 여러 설정의 진입점입니다. 로그아웃 성공 시 / 주소로 이동합니다. oauth2Login() OAuth 2 로그인 기능에 대한 여러 설정의 진입점입니다. userInfoEndpoint() OAuth 2 로그인 성공 이후 사용자 정보를 가져올 때의 설정들을 담당합니다. userService 소셜 로그인 성공 시 후속 조치를 진행할 UserService 인터페이스의 구현체를 등록합니다. 리소스 서버(즉, 소셜 서비스들)에서 사용자 정보를 가져온 상태에서 추가로 진행하고 자 하는 기능을 명시할 수 있습니다. 2.CustomOAuth2UserService클래스구글 로그인 이후 가져온 사용자의 정보(email, name, picture 등)들을 기반으로 가입 및 정보수정, 세션 저장 등의 기능을 지원합니다. src/main/java/패키지명/config/auth/CustomOAuth2UserService1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import lombok.RequiredArgsConstructor;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.oauth2.client.userinfo.DefaultOAuth2UserService;import org.springframework.security.oauth2.client.userinfo.OAuth2UserRequest;import org.springframework.security.oauth2.client.userinfo.OAuth2UserService;import org.springframework.security.oauth2.core.OAuth2AuthenticationException;import org.springframework.security.oauth2.core.user.DefaultOAuth2User;import org.springframework.security.oauth2.core.user.OAuth2User;import org.springframework.stereotype.Service;import javax.servlet.http.HttpSession;import java.util.Collections;@RequiredArgsConstructor@Servicepublic class CustomOAuth2UserService implements OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; { private final UserRepository userRepository; private final HttpSession httpSession; @Override public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException { OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; delegate = new DefaultOAuth2UserService(); OAuth2User oAuth2User = delegate.loadUser(userRequest); String registractionId=userRequest.getClientRegistration().getProviderDetails() .getUserInfoEndpoint().getUserNameAttributeName(); String userNameAttributeName=userRequest.getClientRegistration().getProviderDetails().getUserInfoEndpoint().getUserNameAttributeName(); OAuthAttributes attributes = OAuthAttributes.of(registractionId, userNameAttributeName, oAuth2User.getAttributes()); User user = saveOrUpdate(attributes); httpSession.setAttribute(&quot;user&quot;,new SessionUser(user)); return new DefaultOAuth2User(Collections.singleton(new SimpleGrantedAuthority(user.getRolekey())), attributes.getAttributes(), attributes.getNameAttributekey()); } private User saveOrUpdate(OAuthAttributes attributes){ User user = userRepository.findByEmail(attributes.getEmail()) .map(entity -&gt; entity.update(attributes.getName(),attributes.getPicture())) .orElse(attributes.toEntity()); return userRepository.save(user); }} getRegistrationId 현재 로그인 진행 중인 서비스를 구분하는 코드입니다. 지금은 구글만 사용하는 불필요한 값이지만, 이후 네이버 로그인 연동 시에 네이버로 로그인인지, 구글 로그인인지 구분하기 위해 사용합니다. getUserNameAttributeName OAuth2 로그인 진행 시 키가 되는 필드값을 이야기합니다. Primary Key와 같은 의미입니다. 구글의 경우 기본적으로 코드를 지원하지만, 네이버 카카오 등은 기본 지원하지 않습니다. 구글의 기본 코드는 “sub” 입니다. 이후 네이버 로그인과 구글 로그인을 동시 지원할 때 사용됩니다. OAuthAttributes OAuth2userService를 통해 가져온 OAuth2User의 attribute를 담을 클래스입니다. 이후 네이버 등 다른 소셜 로그인도 이 클래스를 사용합니다. 바로 아래에서 이 클래스의 코드가 나오니 차례로 생성하시면 됩니다. SessionUser 세션에 사용자 정보를 저장하기 위한 Dto 클래스입니다. 왜 User클래스를 쓰지 않고 새로 만들어서 쓰는지는 아래에서 설명하겠습니다. saveOrUpdate 구글 사용자 정보가 업데이트 되었을 때를 대비하여 update 기능도 같이 구현하였습니다. 사용자의 이름이나 프로필 사진이 변경되면 User 엔티티에도 반영됩니다. 왜 User클래스를 사용하면 안되는가? 만약 User클래스를 그대로 사용했다면 에러가 발생합니다.에러의 내용은 “User클래스에 직렬화를 구현하지 않았다” 입니다.그럼 User클래스에 직렬화 코드를 넣으면 된다고 생각할 수 도 있습니다.하지만 User클래스가 엔티티이기 때문에 넣지 않는게 좋습니다.엔티티 클래스에는 언제 다른 엔티티와 관계가 형성될지 모릅니다.예를 들어 @OneToMany, @ManyToMany 등 자식 엔티티를 갖고 있다면 직렬화 대상에 자식들까지 포함되니 성능 이슈, 부수 효과가 발생할 확률이 높습니다.그래서 직렬화 기능을 가진 세션 Dto를 하나 추가로 만드는 것이 이후 운영 및 유지보수 때 많은 도움이 됩니다. 3.OAuthAttributes 클래스저자는 OAuthAttributes를 dto클래스로 간주합니다.config.auth.dto 패키지를 만들어 그 안에 클래스 생성합니다 src/main/java/패키지명/config/auth/dto/OAuthAttributes123456789101112131415161718192021222324252627282930313233343536373839404142434445import lombok.Builder;import lombok.Getter;import java.util.Map;@Getterpublic class OAuthAttributes { private Map&lt;String, Object&gt; attributes; private String nameAttributekey; private String name; private String email; private String picture; @Builder public OAuthAttributes(Map&lt;String, Object&gt; attributes,String nameAttributekey, String name, String email, String picture){ this.attributes=attributes; this.nameAttributekey=nameAttributekey; this.name=name; this.email=email; this.picture=picture; } public static OAuthAttributes of(String registrationId, String userNameAttributeName, Map&lt;String, Object&gt; attributes){ return ofGoogle(userNameAttributeName, attributes); } private static OAuthAttributes ofGoogle(String userNameAttributeName, Map&lt;String, Object&gt; attributes){ return OAuthAttributes.builder() .name((String) attributes.get(&quot;name&quot;)) .email((String) attributes.get(&quot;email&quot;)) .picture((String) attributes.get(&quot;picture&quot;)) .attributes(attributes) .nameAttributekey(userNameAttributeName) .build(); } public User toEntity(){ return User.builder() .name(name) .email(email) .picture(picture) .role(Role.GUEST) .build(); }} of() OAuth2User에서 반환하는 사용자 정보는 Map이기 때문에 값 하나하나를 변환해야만 합니다. toEntity() User 엔티티를 생성합니다. OAuthAttribute에서 엔티티를 생성하는 시점은 처음 가입할 때입니다. 가입할 때의 기본 권한을 GUEST로 주기 위해서 role 빌더값에는 Role.GUEST를 사용합니다. 4.SessionUser 클래스인증된 사용자의 정보만 가져옵니다.config.auth.dto패키지에 SessionUser클래스를 생성합니다. src/main/java/패키지명/config/auth/dto/SessionUser12345678910111213141516import lombok.Getter;import java.io.Serializable;@Getterpublic class SessionUser implements Serializable { private String name; private String email; private String picture; public SessionUser(User user) { this.name = user.getName(); this.email = user.getEmail(); this.picture = user.getPicture(); }} 모든 시큐리티 설정이 끝났습니다. 그럼 로그인 기능을 한번 테스트 해보겠습니다. 로그인 테스트스프링 시큐리티가 잘 적용되었는지 확인하기 위해 화면에 로그인 버튼을 추가해 보겠습니다. index.mustache에 로그인 버튼과 로그인 성공 시 사용자 이름을 보여주는 코드입니다. index.mustache123456789101112131415161718&lt;h1&gt;스프링 부트로 시작하는 웹 서비스&lt;/h1&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;div calss=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;a href=&quot;/posts/save&quot; role=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;글 등록&lt;/a&gt; {{#userName}} Logged in as: &lt;span id=&quot;user&quot;&gt;&lt;/span&gt; &lt;a href=&quot;/logout&quot; class=&quot;btn btn-info active&quot; role=&quot;button&quot;&gt;Logout&lt;/a&gt; {{/userName}} {{^userName}} &lt;a href=&quot;/oauth2/authorization/google&quot; class=&quot;btn btn-success active&quot; role=&quot;button&quot;&gt;Google Login&lt;/a&gt; {{/userName}} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;!--목록 출력 영역--&gt; {{#userName}} 머스테치는 다른 언어와 같은 if문(if userName != null)을 제공하지 않습니다. true/false 여부만 판단할 뿐입니다. 그래서 머스테치에서는 항상 최종값을 넘겨줘야 합니다. 여기서도 역시 userName이 있다면 userName을 노출시키도록 구성했습니다. a href=”/logout” 스프링 시큐리티에서 기본적으로 제공하는 로그아웃 URL 입니다. 즉, 개발자가 별도로 저 URL에 해당하는 컨트롤러를 만들 필요가 없습니다. SecurityConfig클래스에서 URL을 변경할 순 있지만 기본 URL을 사용해도 충분하니 여기서는 그래도 사용합니다. {{^userName}} 머스테치에서 해당 값이 존재하지 않는 경우에는 ^를 사용합니다. 여기서는 userName이 없다면 로그인 버튼을 노출시키도록 구성했습니다. a href=”/oauth2/authorization/google” 스프링 시큐리티에서 기본적으로 제공하는 로그인 URL입니다. 로그아웃 URL과 마찬가지로 개발자가 별도의 컨트롤러를 생성할 필요가 없습니다. index.mustache에서 userName을 사용할 수 있게 IndexController에서 userName을 model에 저장하는 코드를 추가해줍니다. IndexController1234567891011121314151617181920212223import javax.servlet.http.HttpSession;@RequiredArgsConstructor@Controllerpublic class indexController { private final PostsService postsService; private final HttpSession httpSession; @GetMapping(&quot;/&quot;) public String index(Model model){ model.addAttribute(&quot;posts&quot;,postsService.findAllDesc()); SessionUser user = (SessionUser) httpSession.getAttribute(&quot;user&quot;); if(user != null){ model.addAttribute(&quot;userName&quot;, user.getName()); } return &quot;index&quot;; } ... 중략} (SessionUser) httpSession.getAttribute(“user”); 앞서 작성된 CustomOAuth2UserService에서 로그인 성공 시 세션에 SessionUser를 저장하도록 구성했습니다. 즉, 로그인 성공 시 httpSession.getAttribute(“user”)에서 값을 가져올 수 있습니다. if(user != null) 세션에 저장된 값이 있을 때만 model에 userName으로 등록합니다. 세션에 저장된 값이 없으면 model엔 아무런 값이 없는 상태이니 로그인 버튼이 보이게 됩니다. 로그인은 정상적으로 동작하는 것을 볼 수 있습니다.h2-console에서 user테이블에 회원정보가 들어간 것 까지 확인할 수 있습니다.하지만 게시글 등록은 403에러(권한 거부)를 띄우게 됩니다.이는 현재 로그인된 사용자의 권한이 GUEST이기 때문입니다.h2-console에서 사용자의 role을 User로 변경합니다. 세션에는 GUEST의 정보로 저장되었으니 로그아웃후 다시 로그인 하면 게시글 등록 또한 정상적으로 동작 함을 볼 수 있습니다. 3. 어노테이션 기반으로 개선하기프로그래밍에서 개선이 필요한 나쁜 코드는 같은 코드가 반복 되는 부분입니다. 같은 코드가 반복되는 부분이 많아지면 이후 수정이 필요할 때 모든 부분을 하나씩 찾아가며 수정해야만 합니다. 이렇게 될 경우 유지보수성이 떨어질 수 밖에 없으며, 혹시나 수정이 반영되지 않은 반복 코드가 있다면 문제가 발생할 수밖에 없습니다. 앞서 만든 것들 중 IndexController에서 세션값을 가져오는 부분이 반복되는 코드입니다. 1SessionUser user = (SessionUser) httpSession.getAttribute(&quot;user&quot;); index메소드 외에 다른 컨트롤러와 메소드에서 세션값이 필요하면 그때마다 직접 세션에서 값을 가져와야 합니다.그래서 이 부분을 메소드 인자로 세션값을 바로 받을 수 있도록 변경해 보겠습니다. config.auth 패키지에 @LoginUser 어노테이션을 생성합니다. src/main/java/패키지명/config/auth/LoginUser12345678910import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)public @interface LoginUser {} @Target(ElementType.PARAMETER) 이 어노테이션이 생성될 수 있는 위치를 지정합니다. PARAMETER로 지정했으니 메소드의 파라미터로 선언된 객체에서만 사용할 수 있습니다. 이 외에도 클래스 선언문에 쓸 수 있는 TYPE 등이 있습니다. @interface 이 파일을 어노테이션 클래스로 지정합니다. LoginUser라는 이름을 가진 어노테이션이 생성되었다고 보면 됩니다. 그리고 같은 위치에 LoginUserArgumentResolver를 생성 합니다.이 클래스는 HandlerMethodArgumentResolver 인터페이스를 구현한 클래스입니다. HandlerMethodArgumentResolver는 한가지 기능을 지원합니다.바로 조건에 맞는 경우 메소드가 있다면 HandlerMethodArgumentResolver의 구현체가 지정한 값으로 해당 메소드의 파라미터로 넘길 수 있습니다. LoginUserArgumentResolver12345678910111213141516171819202122232425262728293031import lombok.RequiredArgsConstructor;import org.springframework.core.MethodParameter;import org.springframework.stereotype.Component;import org.springframework.web.bind.support.WebDataBinderFactory;import org.springframework.web.context.request.NativeWebRequest;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.method.support.ModelAndViewContainer;import javax.servlet.http.HttpSession;@RequiredArgsConstructor@Componentpublic class LoginUserArgumentResolver implements HandlerMethodArgumentResolver { private final HttpSession httpSession; @Override public boolean supportsParameter(MethodParameter parameter) { boolean isLoginUserAnnotation = parameter.getParameterAnnotation(LoginUser.class) != null; boolean isUserClass = SessionUser.class.equals(parameter.getParameterType()); return isLoginUserAnnotation &amp;&amp; isUserClass; } @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { return httpSession.getAttribute(&quot;user&quot;); }} supportsParameter() 컨트롤러 메서드의 특정 파라미터를 지원하는지 판단합니다. 여기서는 파라미터에 @LoginUser어노테이션이 붙어 있고, 파라미터 클래스 타입이 Sessionuser.class인 경우 -true를 반환합니다. resolveArgument() 파라미터에 전달할 객체를 생성합니다. 여기서는 세션에서 객체를 가져옵니다. 생성된 LoginUserArgumentResolver가 스프링에서 인식될 수 있도록 WebMvcConfigurer에 추가하겠습니다.config패키지에 WebConfig클래스를 생성하여 다음과 같이 설정을 추가합니다. src/main/java/패키지명/config/WebConfig1234567891011121314151617import lombok.RequiredArgsConstructor;import org.springframework.context.annotation.Configuration;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.List;@RequiredArgsConstructor@Configurationpublic class WebConfig implements WebMvcConfigurer { private final LoginUserArgumentResolver loginUserArgumentResolver; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) { argumentResolvers.add(loginUserArgumentResolver); }} HandlerMethodArgumentResolver는 항상 WebMvcConfigurer의 addArgumentResolvers()를 통해 추가해야 합니다.다른 Handler-MethodArgumentResolver가 필요 한다면 같은 방식으로 추가해 주면 됩니다. 마지막으로 IndexController의 코드에서 반복되는 부분들을 모두 @LoginUser로 바꾸어 줍니다. 123456789101112131415161718@RequiredArgsConstructor@Controllerpublic class indexController { private final PostsService postsService; private final HttpSession httpSession; @GetMapping(&quot;/&quot;) public String index(Model model, @LoginUser SessionUser user){ model.addAttribute(&quot;posts&quot;,postsService.findAllDesc()); if(user != null){ model.addAttribute(&quot;userName&quot;, user.getName()); } return &quot;index&quot;; } ... 중략} @LoginUser SessionUser user 기존에 (User) httpSession.getAttribute(“user”) 로 가져오던 세션 정보 값이 개선 되었습니다. 이제는 어느 컨트롤러든지 @Loginuser만 사용하면 세션 정보를 가져올 수 있게 되었습니다. 다시 어플리케이션을 실행해 로그인 기능이 정상적으로 작동하는 것을 확인합니다. 4. 세션 저장소로 데이터베이스 사용하기지금 까지 만든 서비스는 어플리케이션을 재실행하면 로그인이 풀립니다. 이는 세션이 내장 톰켓의 메모리에 저장 되기 때문입니다. 기본적으로 세션은 실행되는 WAS의 메모리에서 저장되고 호출됩니다. 메모리에 저장되다 보니 내장 톰캣처럼 애플리케이션 실행 시 실행되는 구조에선 항상 초기화가 됩니다. 즉, 배포할 때마다 톰캣이 재시작되는 것 입니다. 이 외에도 한 가지 문제가 더 있습니다. 2대 이상의 서버에서 서비스하고 있다면 톰캣마다 세션 동기화 설정을 해야만 합니다. 그래서 실제 현업에서는 세션 저장소에 대해 다음의 3가지 중 한 가지를 선택합니다. 1.톰캣 세션을 사용한다 일반적으로 별다른 설정을 하지 않을 때 기본적으로 선택되는 방식입니다. 이렇게 될 경우 톰캣(WAS)에 세션이 저장되기 떄문에 2대 이상의 WAS가 구동되는 환경에서는 톰캣들 간의 세션 공유를 위한 추가 설정이 필요합니다. 2.MySQL과 같은 데이터베이스를 세션 저장소로 사용한다. 여러 WAS 간의 공용 세션을 사용할 수 있는 가장 쉬운 방법입니다. 많은 설정이 필요 없지만, 결국 로그인 요청마다 DB IO가 발생하여 성능상 이슈가 발생할 수 있습니다. 보통 로그인 요청이 많이 없는 백오피스, 사내 시스템 용도에서 사용합니다. 3.MySQL과 같은 데이터베이스를 세션 저장소로 사용한다. 여러 WAS 간의 공용 세션을 사용할 수 있는 가장 쉬운 방법입니다. 많은 설정이 필요 없지만, 결국 로그인 요청마다 DB IO가 발생하여 성능상 이슈가 발생할 수 있습니다. 보통 로그인 요청이 많이 없는 백오피스, 사내 시스템 용도에서 사용합니다. 여기서는 두 번째 방식인 데이터베이스를 세션 저장소로 사용하는 방식을 선택하여 진행하겠습니다. build.gradle에 spring-session-jdbc의존성을 등록 해 줍니다. 1compile('org.springframework.session:spring-session-jdbc') 그리고 application.properties에 세션 저장소를 jdbc로 선택하도록 코드를 추가합니다. 1spring.session.store-type=jdbc 모두 변경하였으니 다시 애플리케이션을 실행해서 로그인을 테스트한 뒤, h2-console로 접속합니다.h2-console을 보면 세션을 위한 테이블 2개(SPRING_SESSION, SPRING_SESSION_ATTRIBUTES)가 생성된 것을 볼수 있습니다.JPA로 인해 세션 테이블이 자동 생성되었기 때문에 별도로 해야 할 일은 없습니다.방금 로그인했기 떄문에 한 개의 세션이 등록돼있는 것을 볼 수 있습니다. 1SELECT * FROM SPRING_SESSION 세션 저장소를 데이터베이스로 교체했습니다.물론 지금은 기존과 동일하게 스프링을 재시작하면 세션이 풀립니다.이유는 H2기반으로 스프링이 재실행될 때 H2도 재시작되기 때문입니다.이는 AWS로 배포하면 해결될 문제이니 다음 과정을 진행하면 됩니다. 5. 네이버 로그인마지막으로 네이버 로그인을 추가해 보겠습니다. 네이버 API 등록먼저 네이버 오픈 API로 이동합니다. https://developers.naver.com/apps/#/register?api=nvlogin 다음 항목을 채웁니다. 애플리케이션 이름 사용 API → 네아로(네이버 아이디로 로그인) : 필수 항목(회원이름, 이메일, 프로필 사진)체크 로그인 오픈 API 서비스 환경 → 환경추가 → PC 웹 서비스 URL: http://localhost:8080/ 네이버아이디로로그인 Callback URL: http://localhost:8080/login/oauth2/code/naver 등록을 완료하였으면 application-oauth.properties에 clientId, clientSecret키값들을 추가해 줍니다. 네이버에서는 스프링 시큐리티를 공식 지원하지 않기 때문에 그동안 Common-OAuth2Provider에서 해주던 값들도 전부 수동으로 입력해야 합니다. application-oauth.properties123456789101112131415... 중략# registrationspring.security.oauth2.client.registration.naver.client-id=클라이언트 아이디spring.security.oauth2.client.registration.naver.client-secret=클라이언트 보안 비밀spring.security.oauth2.client.registration.naver.redirect-uri={baseUrl}/{action}/oauth2/code/{registrationId}spring.security.oauth2.client.registration.naver.authorization-grant-type=authorization_codespring.security.oauth2.client.registration.naver.scope=name,email,profile_imagespring.security.oauth2.client.registration.naver.client-name=Naver# providerspring.security.oauth2.client.provider.naver.authorization-uri=https://nid.naver.com/oauth2.0/authorizespring.security.oauth2.client.provider.naver.token-uri=https://nid.naver.com/oauth2.0/tokenspring.security.oauth2.client.provider.naver.user-info-uri=https://openapi.naver.com/v1/nid/mespring.security.oauth2.client.provider.naver.user-name-attribute=response user-name-attribute=response 기준이 되는 user-name의 이름을 네이버에서는 response로 해야 합니다. 이유는 네이버의 회원 조회 시 반환되는 JSON형태 떄문입니다. 스프링 시큐리티에선 하위 필드를 명시할 수 없습니다. 최상위 필드만 user-name으로 지정 가능합니다. 하지만 네이버의 응답값 최상위 필드는 resultCode, message, response 입니다. 이러한 이유로 스프링 시큐리티에서 인식 가능한 필드는 저 3개 중에 골라야 합니다. 본문에서 담고 있는 response를 user-name으로 지정하고 이후 자바 코드로 response의 id를 user-name으로 지정하겠습니다. 스프링 시큐리티 설정 등록구글 로그인을 등록하면서 대부분 코드가 확장성 있게 작성되었다 보니 네이버는 쉽게 등록 가능합니다.OAuthAttributes에 다음과 같이 네이버 인지 판단하는 코드와 네이버 생성자만 추가해 주면 됩니다. OAuthAttributes123456789101112131415161718192021222324252627@Getterpublic class OAuthAttributes { ... public static OAuthAttributes of(String registrationId, String userNameAttributeName, Map&lt;String, Object&gt; attributes) { if(&quot;naver&quot;.equals(registrationId)) { return ofNaver(&quot;id&quot;, attributes); } return ofGoogle(userNameAttributeName, attributes); } ... private static OAuthAttributes ofNaver(String userNameAttributeName, Map&lt;String, Object&gt; attributes) { Map&lt;String, Object&gt; response = (Map&lt;String, Object&gt;) attributes.get(&quot;response&quot;); return OAuthAttributes.builder() .name((String) response.get(&quot;name&quot;)) .email((String) response.get(&quot;email&quot;)) .picture((String) response.get(&quot;profile_image&quot;)) .attributes(response) .nameAttributeKey(userNameAttributeName) .build(); } ...} 마지막으로 index.mustache에 네이버 로그인 버튼을 추가합니다. index.mustache12345678910...{{^userName}} &lt;a href=&quot;/oauth2/authorization/google&quot; class=&quot;btn btn-success active&quot; role=&quot;button&quot;&gt;Google Login&lt;/a&gt; &lt;a href=&quot;/oauth2/authorization/naver&quot; class=&quot;btn btn-secondary active&quot; role=&quot;button&quot;&gt;Naver Login&lt;/a&gt;{{/userName}}... href=”/oauth2/authorization/naver” 네이버 로그인 URL은 application-auth.properties에 등록한 redirect-uri 값에 맞춰 자동으로 등록됩니다. /oauth2/authorization/ 까지는 고정이고 마지막 Path만 각 소셜 로그인 코드를 사용하면 됩니다. 여기서는 naver가 마지막 Path가 됩니다. 이제 메인 화면을 확인해 보면 다음과 같이 네이버 버튼이 활성화 된 것을 볼 수 있습니다. 네이버 로그인 버튼을 누르면 동의 화면이 등장합니다.동의 화면 이후 다음과 같이 로그인이 성공하는 것을 확인할 수 있습니다. 6. 기존 테스트에 시큐리티 적용하기기존 테스트에 시큐리티 적용으로 문제가 발생하였습니다. 그 이유는 기존에는 바로 API를 호출할 수 있어 테스트 코드 역시 바로 API를 호출하도록 구성하였습니다. 하지만, 시큐리티 옵션이 활성화되면 인증된 사용자만 API를 호출할 수 있습니다. 기존의 API 테스트 코드들이 모두 인증에 대한 권한을 받지 못하였으므로, 테스트 코드마다 인증한 사용자가 호출한 것처럼 작동하도록 수정하겠습니다. gradle → Tasks → verification → test 실행 해보면 롬복을 이용한 테스트 외에 스프링을 이용한 테스트는 모두 실패하는 것을 볼 수 있습니다. 문제 1. CustomOAuth2UserService을 찾을 수 없음첫 번째 실패 테스트인 “hello가_리턴된다”의 메시지를 보면 “No qualifying bean of type ‘com.패키지명.config.auth.CustomOAuth2-UserService’”라는 메시지가 등장합니다.이 는 CustomOAuth2UserService를 생성하는데 필요한 소셜 로그인 관련 설정값들이 없기 때문 에 발생합니다. application-oauth.properties에 설정값을 추가 했지만 설정이 없다고 나올까요?이는 src/main환경과 src/test환경의 차이 때문입니다. 둘은 본인만의 환경 구성을 가집니다..다만, src/main/resources/application.properties가 테스트 코드를 수행할 때도 적용되는 이유는 test에 application.properties가 없으면 main의 설정을 그대로 가져오기 때문입니다.다만, 자동으로 가져오는 옵션의 범위는 application.properties 파일까지입니다.즉, application-oauth.properties는 test에 파일이 없다고 가져오는 파일은 아니라는 점입니다. 이 문제를 해결하기 위해 테스트 환경을 위한 application.properties를 만들겠습니다.실제로 구글 연동까지 진행할 것은 아니므로 가짜 설정 값을 등록합니다. src/test/resources/application.properties1234567891011spring.jpa.show_sql=truespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialectspring.h2.console.enabled=truespring.profiles.include=oauthspring.session.store-type=jdbc# Test OAuthspring.security.oauth2.client.registration.google.client-id=testspring.security.oauth2.client.registration.google.client-secret=testspring.security.oauth2.client.registration.google.scope=profile,email 문제 2. 302 Status Code두 번째로 “Posts_등록된다” 테스트 로그를 확인해 봅니다.응답 결과로 200(정상)이 아닌 302(리다이렉션 응답) Status Code가 와서 실패 했습니다. 이는 스프링 시큐리티 설정 때문에 인증되지 않은 사용자의 요청은 이동시키기 때문입니다. 그래서 이런 API 요청은 임의로 인증된 사용자를 추가하여 API만 테스트해 볼 수 있게 하겠습니다.스프링 시큐리티 테스트를 위한 여러 도구를 지원하는 spring-security-test를 에 추가합니다. build.gradle1testCompile('org.springframework.security:spring-security-test') 그리고 PostsApiControllerTest 의 2개의 테스트 메소드에 다음과 같이 임의의 사용자 인증을 추가합니다. PostsApiControllerTest1234567891011121314public class PostsApiControllerTest { ... @Test @WithMockUser(roles = &quot;USER&quot;) public void Posts_등록된다() throws Exception { ... } @Test @WithMockUser(roles = &quot;USER&quot;) public void Posts_수정된다() throws Exception { ... }} @WithMockUser(roles = “USER”) 인증된 모의(가짜) 사용자를 만들어서 사용합니다. roles에 권한을 추가할 수 있습니다. 즉, 이 어노테이션으로 인해 ROLE_USER 권한을 가진 사용자가 API를 요청하는 것과 동일한 효과를 가지게 됩니다. 이정도만 하면 실제로 작동하진 않습니다. @WithMockUser가 MockMvc에서만 작동하기 때문입니다. 현재 PostsApiControllerTest @SpringBootTest로만 되어있으며 MockMvc를 전혀 사용하지 않습니다. 그래서 @SpringBootTest에서 MockMvc를 사용하는 방법을 소개합니다.코드를 다음과 같이 변경합니다. PostsApiControllerTest1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import org.springframework.http.MediaType;import org.springframework.security.test.context.support.WithMockUser;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.springSecurity;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class PostsApiControllerTest {...@Autowired private WebApplicationContext context; private MockMvc mvc;@Before public void setup() { mvc = MockMvcBuilders .webAppContextSetup(context) .apply(springSecurity()) .build(); } ...@Test @WithMockUser(roles=&quot;USER&quot;) public void Posts_등록된다() throws Exception { ... //when mvc.perform(post(url) .contentType(MediaType.APPLICATION_JSON_UTF8) .content(new ObjectMapper().writeValueAsString(requestDto))) .andExpect(status().isOk()); //then List&lt;Posts&gt; all = postsRepository.findAll(); assertThat(all.get(0).getTitle()).isEqualTo(title); assertThat(all.get(0).getContent()).isEqualTo(content); } @Test @WithMockUser(roles=&quot;USER&quot;) public void Posts_수정된다() throws Exception { ... //when mvc.perform(put(url) .contentType(MediaType.APPLICATION_JSON_UTF8) .content(new ObjectMapper().writeValueAsString(requestDto))) .andExpect(status().isOk()); //then List&lt;Posts&gt; all = postsRepository.findAll(); assertThat(all.get(0).getTitle()).isEqualTo(expectedTitle); assertThat(all.get(0).getContent()).isEqualTo(expectedContent); }} @Before 매번 테스트가 시작되기 전에 MockMvc 인스턴스를 생성합니다. mvc.perform 생성된 MockMvc를 통해 API를 테스트 합니다. 본문 영역은 문자열로 표현하기 위해 ObjectMapper를 통해 문자열 JSON으로 변환합니다. 문제 3. @WebMvcTest에서 CustomOAuth2UserService을 찾을 수 없음제일 앞에서 발생한 “hellor가_리턴된다” 테스트를 확인해 봅니다. 그럼 첫 번째로 해결한 것과 동일한 “No qualifying bean of type ‘패키지명.config.auth.CustomOAuth2UserService’”입니다. HelloControllerTest는 1번과는 조금 다른점이 있습니다. 바로 @WebMvcTest를 사용한다는 점입니다. 1번을 통해 스프링 시큐리티 설정은 잘 작동했지만, @WebMvcTest는 CustomOAuth2UserService를 스캔하지 않기 때문입니다. @WebMvcTest는 WebSecurityConfigurerAdapter, WebMvcConfigurer를 비롯한 @ControllerAdvice, @Controller를 읽습니다. 즉, @Repository, @Service, @Component는 스캔 대상이 아닙니다. 그러니 SecurityConfig는 읽었지만, SecurityConfig를 생성하기 위해 필요한 CustomOAuth2UserService는 읽을수가 없어 앞에서와 같은 에러가 발생한 것입니다. 이 문제를 해결하기 위해 스캔 대상에서 SecurityConfig를 제거 합니다. HelloControllerTest1234@WebMvcTest(controllers = HelloController.class, excludeFilters = { @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = SecurityConfig.class) }) 언제 삭제될지 모르니 사용하지 않으시는걸 추천합니다. 그리고 여기서도 마찬가지로 @WithMockUser를 사용해서 가짜로 인증된 사용자를 생성합니다. 1234567891011@WithMockUser(roles = &quot;USER&quot;)@Testpublic void hello_리턴된다() throws Exception { ...}@WithMockUser(roles = &quot;USER&quot;)@Testpublic void helloDto가_리턴된다() throws Exception{ ...} 이렇게 한 뒤 다시 테스트를 돌려보면 @EnableJpaAuditing로 인한 추가 에러가 발생합니다. @EnableJpaAuditing를 사용하기 위해선 최소 하나의 @Entity 클래스가 필요합니다. @WebMvcTest이다 보니 당연히 없습니다. @EnableJpaAuditing가 @SpringBootApplication와 함께 있다보니 @WebMvcTest에서도 스캔하게 되었습니다. 그래서 @EnableJpaAuditing과 @SpringBootApplication 둘을 분리하겠습니다. Application.java에서 @EnableJpaAuditing를 제거 합니다. Application.java1234567//@EnableJpaAuditing가 삭제됨@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} config패키지에 JpaConfig를 생성하여 @EnableJpaAuditing를 추가 합니다 src/main/java/패키지명/config/JpaConfig1234567import org.springframework.context.annotation.Configuration;import org.springframework.data.jpa.repository.config.EnableJpaAuditing;@Configuration@EnableJpaAuditing //JPA Auditing 활성화public class JpaConfig {} 그리고 다시 전체 테스트를 수행해 봅니다.그럼 모든 테스트가 성공하는 것을 볼 수 있습니다.","link":"/2021/01/23/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0%EC%99%80-OAuth2-0/"}],"tags":[{"name":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","slug":"스프링-부트와-AWS로-혼자-구현하는-웹-서비스","link":"/tags/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%99%80-AWS%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"name":"머스테치","slug":"머스테치","link":"/tags/%EB%A8%B8%EC%8A%A4%ED%85%8C%EC%B9%98/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"깃허브 블로그","slug":"깃허브-블로그","link":"/tags/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"테스트 코드","slug":"테스트-코드","link":"/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C/"},{"name":"JPA","slug":"JPA","link":"/tags/JPA/"},{"name":"스프링 시큐리티","slug":"스프링-시큐리티","link":"/tags/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/"},{"name":"OAuth 2.0","slug":"OAuth-2-0","link":"/tags/OAuth-2-0/"}],"categories":[{"name":"test","slug":"test","link":"/categories/test/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"}]}